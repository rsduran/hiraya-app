The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
AnswerBox.js
import React, { useState } from 'react';
import { Box, Text, Flex, VStack, Tooltip, Image, useColorMode } from '@chakra-ui/react';
import { motion, AnimatePresence } from 'framer-motion';
import { ChevronDownIcon, ChevronUpIcon } from '@chakra-ui/icons';

const voteColors = {
  light: ["yellow.400", "red.300", "blue.300", "green.300"],
  dark: ["yellow.500", "red.400", "blue.400", "green.400"]
};

const transformImageUrl = (url) => {
  if (!url) return url;
  if (url.startsWith('http://') || url.startsWith('https://')) return url;
  return `https://www.examtopics.com${url}`;
};

const VoteBar = ({ votes }) => {
  const { colorMode } = useColorMode();
  const totalVotes = votes.reduce((sum, vote) => sum + vote.count, 0);
  const colors = voteColors[colorMode];
  
  return (
    <Box 
      width="100%" 
      height="30px" 
      borderRadius="md" 
      overflow="hidden" 
      position="relative"
    >
      <Flex height="100%">
        {votes.map((vote, index) => {
          const percentage = (vote.count / totalVotes) * 100;
          const isSmall = percentage < 10;

          return (
            <Tooltip
              key={index}
              label={`${vote.answer}: ${percentage.toFixed(2)}%`}
              placement="top"
              hasArrow
              bg={colorMode === 'light' ? 'gray.700' : 'gray.200'}
              color={colorMode === 'light' ? 'white' : 'black'}
              isDisabled={!isSmall}
            >
              <Box
                backgroundColor={colors[index]}
                width={`${percentage}%`}
                height="100%"
                position="relative"
                minWidth="1px"
              >
                {!isSmall && (
                  <Text
                    position="absolute"
                    left={2}
                    top="50%"
                    transform="translateY(-50%)"
                    fontSize="14px"
                    fontWeight="bold"
                    color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
                    whiteSpace="nowrap"
                    overflow="hidden"
                    textOverflow="ellipsis"
                  >
                    {vote.answer} {percentage.toFixed(2)}%
                  </Text>
                )}
              </Box>
            </Tooltip>
          );
        })}
      </Flex>
    </Box>
  );
};

const AnswerContent = ({ content, isAnswer }) => {
  const { colorMode } = useColorMode();
  
  const parsedContent = content.split(/<br>|<br\/>/).map((part, index) => {
    if (part.startsWith('<img')) {
      const srcMatch = part.match(/src="([^"]+)"/);
      if (srcMatch) {
        const src = transformImageUrl(srcMatch[1]);
        return <Image key={index} src={src} alt="Answer content" />;
      }
    }
    const textContent = part.replace(/<[^>]*>/g, '');
    if (index === 0 && isAnswer) {
      return (
        <Text 
          key={index} 
          fontSize="24px" 
          fontWeight="700" 
          color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
        >
          {textContent}
        </Text>
      );
    }
    return (
      <Text 
        key={index} 
        fontSize="16px" 
        color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
      >
        {textContent}
      </Text>
    );
  });

  return <>{parsedContent}</>;
};

const AnswerBox = ({ answer, answerDescription, votes }) => {
  const { colorMode } = useColorMode();
  const [isOpen, setIsOpen] = useState(false);

  const toggleDropdown = () => {
    setIsOpen(!isOpen);
  };

  return (
    <Box
      width="100%"
      bg={colorMode === 'light' ? 'brand.surface.light' : 'brand.surface.dark'}
      borderRadius="20px"
      border="1px solid"
      borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
      boxShadow={colorMode === 'light' 
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"}
      position="relative"
      overflow="hidden"
      marginTop={4}
    >
      <Flex 
        justifyContent="space-between" 
        alignItems="center" 
        padding={6}
        onClick={toggleDropdown} 
        cursor="pointer"
      >
        <Text 
          fontSize="24px" 
          fontWeight="700" 
          color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
        >
          Answer
        </Text>
        {isOpen ? 
          <ChevronUpIcon 
            boxSize={6} 
            color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'} 
          /> : 
          <ChevronDownIcon 
            boxSize={6} 
            color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'} 
          />
        }
      </Flex>
      <AnimatePresence>
        {isOpen && (
          <motion.div
            initial={{ height: 0 }}
            animate={{ height: "auto" }}
            exit={{ height: 0 }}
            transition={{ duration: 0.3 }}
            style={{ overflow: "hidden" }}
          >
            <VStack spacing={4} align="stretch" paddingX={6} paddingBottom={6}>
              <AnswerContent content={answer} isAnswer={true} />
              {answerDescription && (
                <AnswerContent content={answerDescription} isAnswer={false} />
              )}
              <Text 
                fontSize="24px" 
                fontWeight="700" 
                color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
              >
                Votes:
              </Text>
              <VoteBar votes={votes} />
            </VStack>
          </motion.div>
        )}
      </AnimatePresence>
    </Box>
  );
};

export default AnswerBox;
----
BadgeUrls.js
export const badgeUrls = {
  "AWS Certified Cloud Practitioner": 
    "https://images.credly.com/images/00634f82-b07f-4bbd-a6bb-53de397fc3a6/image.png",
  "AWS Certified Machine Learning Specialty": 
    "https://images.credly.com/images/778bde6c-ad1c-4312-ac33-2fa40d50a147/image.png",
  "AWS Certified Solutions Architect Associate": 
    "https://images.credly.com/images/0e284c3f-5164-4b21-8660-0d84737941bc/image.png",
  "AWS Certified Developer Associate": 
    "https://images.credly.com/images/b9feab85-1a43-4f6c-99a5-631b88d5461b/twitter_thumb_201604_image.png",
  "AWS Certified Database Specialty": 
    "https://images.credly.com/images/885d38e4-55c0-4c35-b4ed-694e2b26be6c/image.png",
  "AWS Certified Solutions Architect Professional": 
    "https://images.credly.com/images/2d84e428-9078-49b6-a804-13c15383d0de/twitter_thumb_201604_image.png",
  "AWS Certified Data Analytics Specialty": 
    "https://images.credly.com/images/6430efe4-0ac0-4df6-8f1b-9559d8fcdf27/image.png",
  "AWS Certified Data Engineer Associate": 
    "https://images.credly.com/images/e5c85d7f-4e50-431e-b5af-fa9d9b0596e7/image.png",
  "AWS Certified Advanced Networking Specialty": 
    "https://images.credly.com/images/4d08274f-64c1-495e-986b-3143f51b1371/image.png",
  "AWS Certified SysOps Administrator Associate": 
    "https://images.credly.com/images/f0d3fbb9-bfa7-4017-9989-7bde8eaf42b1/image.png",
  "AWS Certified SAP on AWS Specialty": 
    "https://images.credly.com/images/57bb7f6a-441f-4356-a2f1-7693227a475e/image.png",
  "AWS Certified Security Specialty": 
    "https://images.credly.com/images/53acdae5-d69f-4dda-b650-d02ed7a50dd7/image.png",
  "AWS Certified DevOps Engineer Professional": 
    "https://images.credly.com/images/bd31ef42-d460-493e-8503-39592aaf0458/image.png",
  "AWS Certified Big Data Specialty": 
    "https://images.credly.com/images/1e4003a1-ffd4-4eb9-a9da-e14f486255d9/image.png",
  "AWS Certified Alexa Skill Builder Specialty": 
    "https://images.credly.com/images/dd75723c-9629-4511-8c19-154244c5423a/image.png",
  "AWS Certified SysOps Administrator Associate (Twitter)": 
    "https://images.credly.com/images/f0d3fbb9-bfa7-4017-9989-7bde8eaf42b1/twitter_thumb_201604_image.png",
  "Google Professional Google Workspace Administrator": 
    "https://images.credly.com/images/16d3e89c-4af5-47d8-a502-2a93b02c26d4/twitter_thumb_201604_image.png",
  "Google Professional Data Engineer": 
    "https://images.credly.com/images/2d613ff8-8879-430b-b2d8-925fa29785e8/twitter_thumb_201604_image.png",
  "Google Ads Individual Qualification": 
    "https://dangil.tech/wp-content/uploads/2023/07/95f440c5-001c-4976-9a43-d6631b41d11a-removebg-preview-1.png",
  "Google Cloud Digital Leader": 
    "https://images.credly.com/images/44994cda-b5b0-44cb-9a6d-d29b57163073/twitter_thumb_201604_image.png",
  "Google Professional Cloud Network Engineer": 
    "https://images.credly.com/images/08a802bf-f2fa-44fb-8110-92acf6195738/twitter_thumb_201604_image.png",
  "Google Video Advertising": 
    "https://cdn.prod.website-files.com/64fb3aaa0b5ad657cf3e7091/6553beb0175c7efd85c3dd3c_Google%20Ads%20Video%20Certification.png",
  "Google Professional ChromeOS Administrator": 
    "https://pbs.twimg.com/media/FfTg_POXEAYvXFy.png",
  "Google Search Advertising": 
    "https://www.pageoneppc.com/assets/img/badges/search-certified.png",
  "Google Professional Cloud Database Engineer": 
    "https://images.credly.com/images/275e69a5-33a8-4d9c-bad4-2bdc0dfb7d40/twitter_thumb_201604_image.png",
  "Google Analytics Individual Qualification": 
    "https://framerusercontent.com/images/8lRjLVdJ5qy69IGCISC9dUSUvQ.png",
  "Google Professional Cloud Developer": 
    "https://images.credly.com/images/614465c6-1d80-4ae6-a323-753de224422a/twitter_thumb_201604_image.png",
  "Google G Suite Certification": 
    "https://dw2q8mfb3dci9.cloudfront.net/pub/media/wysiwyg/gcp-gsuite.png",
  "Google Professional Collaboration Engineer": 
    "https://certwizard.com/sites/default/files/2020-04/Google-Collaboration-Engineer-certwizard.png",
  "Google AdWords Fundamentals": 
    "https://simonpointer.com/wp-content/uploads/2020/08/Google_Ads2-600x338.png",
  "Google Professional Machine Learning Engineer": 
    "https://images.credly.com/images/05e71e7e-92a1-4821-8530-4176b2e3c4b4/twitter_thumb_201604_image.png",
  "Google Professional Cloud Security Engineer": 
    "https://images.credly.com/images/4ea0ec5c-6258-4c26-9282-6ed233c0c7ac/image.png",
  "Google Professional Cloud DevOps Engineer": 
    "https://images.credly.com/images/33f08b7e-fa6a-41cd-810a-21cc1c336f6d/twitter_thumb_201604_image.png",
  "Google Associate Cloud Engineer": 
    "https://images.credly.com/size/680x680/images/08096465-cbfc-4c3e-93e5-93c5aa61f23e/image.png",
  "Google Professional Cloud Architect": 
    "https://images.credly.com/images/71c579e0-51fd-4247-b493-d2fa8167157a/twitter_thumb_201604_image.png"
};

export const getBadgeUrl = (examTitle) => {
  // Remove exam code if present
  const titleWithoutCode = examTitle.replace(/^[A-Z0-9-]+:\s*/, '');
  
  // Try to find an exact match
  if (badgeUrls[titleWithoutCode]) {
    return badgeUrls[titleWithoutCode];
  }

  // If no exact match, try to find a partial match
  const partialMatch = Object.keys(badgeUrls).find(key => 
    titleWithoutCode.toLowerCase().includes(key.toLowerCase())
  );

  return partialMatch ? badgeUrls[partialMatch] : `/api/placeholder/150/150`;
};
----
Breadcrumbs.js
import React, { useRef, useEffect, useState } from 'react';
import { Flex, Text, Link, Tooltip, useColorModeValue } from '@chakra-ui/react';
import { ChevronRightIcon } from '@chakra-ui/icons';

// Create a separate BreadcrumbItem component
const BreadcrumbItem = React.memo(({ 
  item, 
  isTruncated, 
  innerRef,
  currentPageColor,
  linkColor,
  hoverColor,
  tooltipBg,
  tooltipColor,
  tooltipBorderColor,
  tooltipBoxShadow
}) => {
  const content = (
    <Text
      color={item.isCurrentPage ? currentPageColor : linkColor}
      fontFamily="body"
      fontWeight="500"
      fontSize="16px"
      whiteSpace="nowrap"
      overflow="hidden"
      textOverflow="ellipsis"
      maxWidth={isTruncated ? "50px" : "none"}
      ref={innerRef}
      as={item.isCurrentPage ? "span" : Link}
      href={item.isCurrentPage ? undefined : item.href}
      _hover={item.isCurrentPage ? undefined : {
        textDecoration: 'underline',
        color: hoverColor
      }}
      transition="color 0.2s"
    >
      {isTruncated ? item.label.slice(0, 3) + '...' : item.label}
    </Text>
  );

  if (isTruncated) {
    return (
      <Tooltip 
        label={item.label} 
        aria-label="Full breadcrumb text"
        bg={tooltipBg}
        color={tooltipColor}
        borderRadius="md"
        border="1px solid"
        borderColor={tooltipBorderColor}
        boxShadow={tooltipBoxShadow}
        padding="2"
        fontSize="sm"
      >
        {content}
      </Tooltip>
    );
  }

  return content;
});

const Breadcrumbs = ({ items }) => {
  const containerRef = useRef(null);
  const itemRefs = useRef([]);
  const [itemWidths, setItemWidths] = useState([]);

  // Theme-aware colors - moved to top level
  const currentPageColor = useColorModeValue('gray.500', 'gray.400');
  const linkColor = useColorModeValue('brand.primary.light', 'brand.primary.dark');
  const hoverColor = useColorModeValue('brand.primary.dark', 'brand.primary.light');
  const separatorColor = useColorModeValue('brand.border.light', 'brand.border.dark');
  const tooltipBg = useColorModeValue('brand.surface.light', 'brand.surface.dark');
  const tooltipColor = useColorModeValue('brand.text.light', 'brand.text.dark');
  const tooltipBorderColor = useColorModeValue('brand.border.light', 'brand.border.dark');
  const tooltipBoxShadow = useColorModeValue(
    '0 4px 0 0 black',
    '0 4px 0 0 rgba(255, 255, 255, 0.2)'
  );

  useEffect(() => {
    const checkOverflow = () => {
      if (containerRef.current) {
        const container = containerRef.current;
        const availableWidth = container.offsetWidth;
        const newItemWidths = itemRefs.current.map(ref => ref ? ref.offsetWidth : 0);
        
        let totalWidth = newItemWidths.reduce((sum, width, index) => sum + width + (index > 0 ? 16 : 0), 0);
        
        if (totalWidth > availableWidth) {
          const middleIndex = Math.floor(items.length / 2);
          let i = middleIndex;
          let j = middleIndex;
          
          while (totalWidth > availableWidth && (i > 0 || j < items.length - 1)) {
            if (i > 0) {
              totalWidth -= newItemWidths[i] - 50;
              newItemWidths[i] = 50;
              i--;
            }
            if (j < items.length - 1 && totalWidth > availableWidth) {
              totalWidth -= newItemWidths[j] - 50;
              newItemWidths[j] = 50;
              j++;
            }
          }
        } else {
          newItemWidths.fill(null);
        }
        
        setItemWidths(newItemWidths);
      }
    };

    checkOverflow();
    window.addEventListener('resize', checkOverflow);
    return () => window.removeEventListener('resize', checkOverflow);
  }, [items]);

  return (
    <Flex 
      align="center" 
      ref={containerRef} 
      overflow="hidden" 
      width="100%"
      transition="all 0.2s"
    >
      {items.map((item, index) => (
        <React.Fragment key={index}>
          {index > 0 && (
            <ChevronRightIcon 
              mx={1} 
              color={separatorColor} 
              flexShrink={0} 
              boxSize={3}
              transition="color 0.2s"
            />
          )}
          <BreadcrumbItem
            item={item}
            isTruncated={itemWidths[index] === 50}
            innerRef={el => itemRefs.current[index] = el}
            currentPageColor={currentPageColor}
            linkColor={linkColor}
            hoverColor={hoverColor}
            tooltipBg={tooltipBg}
            tooltipColor={tooltipColor}
            tooltipBorderColor={tooltipBorderColor}
            tooltipBoxShadow={tooltipBoxShadow}
          />
        </React.Fragment>
      ))}
    </Flex>
  );
};

export default Breadcrumbs;
----
CategoriesDropdown.js
import React, { useState, useRef, useEffect, useMemo } from 'react';
import { Box, Text, Button, Tooltip, useColorMode } from '@chakra-ui/react';
import { ChevronDownIcon, ChevronUpIcon } from '@chakra-ui/icons';

const CategoryItem = React.memo(({ category, isSelected, onClick }) => {
  const { colorMode } = useColorMode();
  const itemRef = useRef(null);
  const [isItemTruncated, setIsItemTruncated] = useState(false);

  useEffect(() => {
    if (itemRef.current) {
      setIsItemTruncated(itemRef.current.scrollWidth > itemRef.current.clientWidth);
    }
  }, []);

  return (
    <Tooltip label={category} isDisabled={!isItemTruncated}>
      <Box
        padding={3}
        cursor="pointer"
        backgroundColor={isSelected 
          ? colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"
          : colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"
        }
        _hover={{
          backgroundColor: isSelected 
            ? colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"
            : colorMode === 'light' ? "brand.secondary.light" : "brand.secondary.dark"
        }}
        onClick={onClick}
      >
        <Text
          ref={itemRef}
          fontWeight={700}
          fontSize="16px"
          lineHeight="19px"
          color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
          isTruncated
        >
          {category}
        </Text>
      </Box>
    </Tooltip>
  );
});

const CategoriesDropdown = ({ categories, selectedCategory, onSelect }) => {
  const { colorMode } = useColorMode();
  const [isOpen, setIsOpen] = useState(false);
  const [isTruncated, setIsTruncated] = useState(false);
  const textRef = useRef(null);

  useEffect(() => {
    if (textRef.current) {
      setIsTruncated(textRef.current.scrollWidth > textRef.current.clientWidth);
    }
  }, [selectedCategory]);

  const toggleDropdown = () => {
    setIsOpen(!isOpen);
  };

  const handleSelect = (category) => {
    onSelect(category);
    setIsOpen(false);
  };

  const sortedCategories = useMemo(() => {
    // Separate "All Categories", "Other Certifications" and regular categories
    const allCategories = categories.find(cat => cat === "All Categories");
    const otherCertifications = categories.find(cat => cat === "Other Certifications");
    const regularCategories = categories.filter(cat => 
      cat !== "Other Certifications" && cat !== "All Categories"
    );
    
    // Sort regular categories alphabetically
    const sortedRegular = regularCategories.sort((a, b) => a.localeCompare(b));
    
    // Combine them in the desired order, ensuring "All Categories" is first
    return [
      allCategories || "All Categories", // Always include "All Categories"
      ...sortedRegular,
      otherCertifications
    ].filter(Boolean);
  }, [categories]);

  return (
    <Box position="relative" width="100%">
      <Tooltip label={selectedCategory} isDisabled={!isTruncated}>
        <Button
          onClick={toggleDropdown}
          width="100%"
          backgroundColor={colorMode === 'light' 
            ? "brand.background.light" 
            : "brand.surface.dark"}
          color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
          fontWeight={700}
          fontSize="16px"
          lineHeight="19px"
          borderRadius="10px"
          border="1px solid"
          borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
          boxShadow="none"
          _hover={{
            backgroundColor: colorMode === 'light' 
              ? "brand.primary.light" 
              : "brand.primary.dark",
            boxShadow: colorMode === 'light'
              ? "0 3px 0 0 black"
              : "0 3px 0 0 rgba(255, 255, 255, 0.2)",
          }}
          _active={{
            backgroundColor: colorMode === 'light' 
              ? "brand.primary.light" 
              : "brand.primary.dark",
            boxShadow: "none",
          }}
          transition="all 0.2s"
          display="flex"
          justifyContent="space-between"
          alignItems="center"
          paddingLeft={4}
          paddingRight={4}
          paddingTop={3}
          paddingBottom={3}
        >
          <Text 
            ref={textRef} 
            isTruncated
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
          >
            {selectedCategory}
          </Text>
          {isOpen ? <ChevronUpIcon /> : <ChevronDownIcon />}
        </Button>
      </Tooltip>
      {isOpen && (
        <Box
          position="absolute"
          top="100%"
          left={0}
          width="100%"
          maxHeight="300px"
          backgroundColor={colorMode === 'light' 
            ? "brand.background.light" 
            : "rgba(255, 255, 255, 0.2)"}
          borderRadius="10px"
          border="1px solid"
          borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
          marginTop={2}
          zIndex={1}
          overflowY="auto"
        >
          {sortedCategories.map((category, index) => (
            <CategoryItem
              key={index}
              category={category}
              isSelected={category === selectedCategory}
              onClick={() => handleSelect(category)}
            />
          ))}
        </Box>
      )}
    </Box>
  );
};

export default CategoriesDropdown;
----
CategoryCard.js
import React, { useState } from "react";
import { Box, Text, Flex, Input, Icon, useColorMode } from "@chakra-ui/react";
import { BsBookmarkFill } from 'react-icons/bs';
import ProviderInfoCard from "./ProviderInfoCard";

const CategoryCard = ({ categoryName, providers, view }) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [isBookmarked, setIsBookmarked] = useState(false);
  const { colorMode } = useColorMode();

  const filteredProviders = providers.filter(provider => 
    provider.name.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const toggleBookmark = () => {
    setIsBookmarked(!isBookmarked);
  };

  return (
    <Box
      backgroundColor={colorMode === 'light' ? "brand.surface.light" : "brand.surface.dark"}
      borderRadius="20px"
      border="1px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      boxShadow={colorMode === 'light' 
        ? "0 4px 0 0 black" 
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"}
      padding={6}
      marginBottom={8}
      width="100%"
    >
      <Flex
        justifyContent="space-between"
        alignItems="center"
        marginBottom={6}
        flexWrap="wrap"
        gap={4}
      >
        <Text
          fontSize={{ base: "24px", md: "26px", lg: "28px" }}
          fontWeight="bold"
          color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
        >
          {categoryName}
        </Text>
        <Flex alignItems="center" gap={4}>
          <Box
              as="button"
              onClick={toggleBookmark}
              transition="all 0.2s"
              _hover={{ transform: "scale(1.1)" }}
              _active={{ transform: "scale(0.9)" }}
            >
              <Icon
                as={BsBookmarkFill}
                color={isBookmarked 
                  ? "#FFD700"  // Keep original gold color for bookmark
                  : colorMode === 'light' ? "white" : "gray.600"
                }
                boxSize={6}
                strokeWidth={1}
                stroke={colorMode === 'light' ? "black" : "white"}
                transition="all 0.2s"
              />
            </Box>
          <Input
            placeholder="Search providers..."
            size="md"
            width={{ base: "100%", sm: "200px", md: "250px", lg: "300px" }}
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            backgroundColor={colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"}
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
            borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
            _placeholder={{
              color: colorMode === 'light' 
                ? "rgba(0, 0, 0, 0.6)" 
                : "rgba(255, 255, 255, 0.6)"
            }}
          />
        </Flex>
      </Flex>
      {view === "grid" ? (
        <Box overflowX="auto" paddingBottom={4}>
          <Flex 
            gap={6} 
            wrap="nowrap" 
            width={`calc(300px * ${Math.ceil(filteredProviders.length / 5)} + 24px * ${Math.ceil(filteredProviders.length / 5) - 1})`}
          >
            {filteredProviders.map((provider, index) => (
              <Box
                key={index}
                flex="0 0 auto"
                width="300px"
              >
                <ProviderInfoCard
                  provider={provider}
                  view={view}
                />
              </Box>
            ))}
          </Flex>
        </Box>
      ) : (
        <Box>
          {filteredProviders.map((provider, index) => (
            <ProviderInfoCard
              key={index}
              provider={provider}
              view={view}
            />
          ))}
        </Box>
      )}
    </Box>
  );
};

export default CategoryCard;
----
ComingSoonComponent.js
import React, { useState } from 'react';
import { Box, Text, VStack, Input, Button, Flex, useToast, useColorMode } from '@chakra-ui/react';
import { RiMailSendLine } from 'react-icons/ri';

const ComingSoonComponent = () => {
  const [email, setEmail] = useState('');
  const toast = useToast();
  const { colorMode } = useColorMode();

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Email submitted:', email);
    toast({
      title: "You're on the list!",
      description: "We'll notify you when the Custom Exam feature is ready.",
      status: "success",
      duration: 5000,
      isClosable: true,
    });
    setEmail('');
  };

  return (
    <Flex
      width="100%"
      height="100%"
      alignItems="center"
      justifyContent="center"
    >
      <Box
        w="100%"
        maxW="800px"
        bgGradient={colorMode === 'light' 
          ? "linear(to-br, #4158D0, #C850C0, #FFCC70)"
          : "linear(to-br, #2A3B97, #8C2F89, #B38537)"  // Darker, more muted versions of the light mode colors
        }
        borderRadius="20px"
        border="1px solid"
        borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
        boxShadow={colorMode === 'light' 
          ? "0 8px 0 0 black"
          : "0 8px 0 0 rgba(255, 255, 255, 0.2)"
        }
        position="relative"
        overflow="hidden"
        p={8}
      >
        <VStack spacing={6} align="stretch">
          <Text
            fontSize="48px"
            fontWeight="800"
            color="white"
            textAlign="center"
            fontFamily="heading"
            textShadow={colorMode === 'light'
              ? "2px 2px 4px rgba(0,0,0,0.3)"
              : "2px 2px 4px rgba(0,0,0,0.5)"
            }
          >
            Custom Exam
          </Text>
          <Text
            fontSize="28px"
            fontWeight="700"
            color={colorMode === 'light' ? '#FFCC70' : '#B38537'}  // Using the last gradient color
            textAlign="center"
            textShadow={colorMode === 'light'
              ? "1px 1px 2px rgba(0,0,0,0.2)"
              : "1px 1px 2px rgba(0,0,0,0.4)"
            }
          >
            Coming Soon!
          </Text>
          <Text 
            fontSize="18px" 
            color="white" 
            textAlign="center" 
            lineHeight="1.6"
          >
            We're working hard to bring you the ability to create custom exams.
            <br />
            Enter your email below to be notified when this feature is ready!
          </Text>
          <form onSubmit={handleSubmit}>
            <Flex flexDirection="column" alignItems="center">
              <Input
                type="email"
                placeholder="Enter your email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                bg={colorMode === 'light' ? 'white' : 'brand.surface.dark'}
                color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
                borderRadius="full"
                border="1px solid"
                borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
                height="48px"
                width="100%"
                maxWidth="400px"
                mb={4}
                _focus={{
                  boxShadow: 'none',
                  borderColor: colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark',
                }}
                _placeholder={{
                  color: colorMode === 'light' 
                    ? 'rgba(0,0,0,0.6)' 
                    : 'rgba(255,255,255,0.6)',
                }}
              />
              <Button
                type="submit"
                height="48px"
                fontSize="16px"
                px="24px"
                bg={colorMode === 'light' ? '#FFCC70' : '#B38537'}  // Using the last gradient color
                color={colorMode === 'light' ? 'black' : 'white'}
                borderRadius="full"
                border="1px solid"
                borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
                fontWeight={700}
                textTransform="uppercase"
                transition="0.3s"
                boxShadow={colorMode === 'light'
                  ? "0 4px 0 0 black"
                  : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
                }
                _hover={{
                  transform: 'translateY(2px)',
                  boxShadow: colorMode === 'light'
                    ? "0 2px 0 0 black"
                    : "0 2px 0 0 rgba(255, 255, 255, 0.2)",
                  bg: colorMode === 'light' ? '#FFD584' : '#C49245',  // Slightly lighter hover state
                }}
                _active={{
                  transform: 'translateY(4px)',
                  boxShadow: 'none',
                }}
                leftIcon={<RiMailSendLine />}
              >
                Notify Me
              </Button>
            </Flex>
          </form>
        </VStack>
        <Box
          position="absolute"
          bottom="-50px"
          right="-50px"
          width="200px"
          height="200px"
          borderRadius="full"
          bg={colorMode === 'light' 
            ? "rgba(255, 255, 255, 0.1)"
            : "rgba(255, 255, 255, 0.05)"
          }
          zIndex={0}
        />
      </Box>
    </Flex>
  );
};

export default ComingSoonComponent;
----
CustomConfirmationDialog.js
import React from 'react';
import {
  Box,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  Button,
  Text,
  Flex,
  useColorMode,
} from '@chakra-ui/react';
import { FaTimes } from 'react-icons/fa';

const CloseButton = ({ onClick, colorMode }) => {
  return (
    <Box
      as="button"
      onClick={onClick}
      display="inline-flex"
      alignItems="center"
      justifyContent="center"
      w="24px"
      h="24px"
      bg="transparent"
      _focus={{ boxShadow: "none" }}
      color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
      borderRadius="50%"
      _hover={{ bg: 'transparent' }} // Ensures no background change on hover
    >
      <FaTimes size="16px" />
    </Box>
  );
};

const CustomButton = ({ children, onClick, isPrimary = false }) => {
  const { colorMode } = useColorMode();

  return (
    <Button
      onClick={onClick}
      height="48px"
      fontSize="16px"
      px="24px"
      bg={isPrimary 
        ? (colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark")
        : (colorMode === 'light' ? "brand.background.light" : "brand.surface.dark")
      }
      color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
      borderRadius="full"
      border="1px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      fontWeight={700}
      textTransform="uppercase"
      transition="0.3s"
      boxShadow={colorMode === 'light' 
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
      }
      _hover={{
        transform: 'translateY(2px)',
        boxShadow: colorMode === 'light'
          ? "0 2px 0 0 black"
          : "0 2px 0 0 rgba(255, 255, 255, 0.2)",
      }}
      _active={{
        transform: 'translateY(4px)',
        boxShadow: 'none',
      }}
    >
      {children}
    </Button>
  );
};

const CustomConfirmationDialog = ({ isOpen, onClose, onConfirm, message }) => {
  const { colorMode } = useColorMode();

  return (
    <Modal isOpen={isOpen} onClose={onClose} isCentered>
      <ModalOverlay />
      <ModalContent
        borderRadius="20px"
        border="1px solid"
        borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
        boxShadow={colorMode === 'light'
          ? "0 8px 0 0 black"
          : "0 8px 0 0 rgba(255, 255, 255, 0.2)"
        }
        bg={colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"}
        p={6}
      >
        <Flex justifyContent="flex-end">
          <CloseButton onClick={onClose} />
        </Flex>
        <ModalHeader
          fontFamily="heading"
          fontWeight="bold"
          fontSize="24px"
          pb={4}
          color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
        >
          Confirm Submission
        </ModalHeader>
        <ModalBody>
          <Text 
            fontFamily="body"
            fontSize="18px"
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
          >
            {message}
          </Text>
        </ModalBody>
        <ModalFooter>
          <Flex justifyContent="flex-end" width="100%" gap={4}>
            <CustomButton onClick={onClose}>
              Cancel
            </CustomButton>
            <CustomButton onClick={onConfirm} isPrimary>
              Submit
            </CustomButton>
          </Flex>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
};

export default CustomConfirmationDialog;
----
CustomDashboardTable.js
import React, { useState, useMemo } from "react";
import { Box, Flex, Text, Button, VStack, Input, useColorMode } from "@chakra-ui/react";
import { PiSortAscending, PiSortDescending } from "react-icons/pi";
import { IoChevronDown, IoChevronUp } from "react-icons/io5";
import { motion, AnimatePresence } from "framer-motion";
import { useNavigate } from "react-router-dom";
import Pagination from "./Pagination";

const CustomCheckbox = ({ isChecked, isIndeterminate, onChange }) => {
  const { colorMode } = useColorMode();
  
  return (
    <Box
      as="button"
      width="20px"
      height="20px"
      borderRadius="4px"
      border="2px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      backgroundColor={isChecked 
        ? colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"
        : colorMode === 'light' ? "brand.background.light" : "brand.background.dark"
      }
      display="flex"
      alignItems="center"
      justifyContent="center"
      onClick={onChange}
      _hover={{ 
        backgroundColor: isChecked
          ? colorMode === 'light' ? "brand.primary.dark" : "brand.primary.light"
          : colorMode === 'light' ? "brand.secondary.light" : "brand.secondary.dark"
      }}
      transition="all 0.2s"
      position="relative"
    >
      {isIndeterminate ? (
        <Box
          width="10px"
          height="2px"
          backgroundColor={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
          position="absolute"
          top="50%"
          left="50%"
          transform="translate(-50%, -50%)"
        />
      ) : (
        isChecked && (
          <Box
            width="10px"
            height="10px"
            borderRadius="2px"
            backgroundColor={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
          />
        )
      )}
    </Box>
  );
};

const CustomButton = ({
  children,
  onClick,
  backgroundColor,
  hoverBackgroundColor,
  isDisabled,
  borderColor,
  ...props
}) => {
  const { colorMode } = useColorMode();
  
  return (
    <Button
      onClick={onClick}
      height="40px"
      paddingLeft="16px"
      paddingRight="16px"
      backgroundColor={backgroundColor || (colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark")}
      color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
      fontWeight={700}
      fontSize="14px"
      borderRadius="full"
      border="1px solid"
      borderColor={borderColor || (colorMode === 'light' ? "brand.border.light" : "brand.border.dark")}
      boxShadow={isDisabled ? "none" : colorMode === 'light' 
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
      }
      _hover={{
        backgroundColor: isDisabled 
          ? backgroundColor 
          : (hoverBackgroundColor || (colorMode === 'light' ? "brand.primary.dark" : "brand.primary.light")),
        transform: isDisabled ? "none" : "translateY(2px)",
        boxShadow: isDisabled ? "none" : colorMode === 'light'
          ? "0 2px 0 0 black"
          : "0 2px 0 0 rgba(255, 255, 255, 0.2)",
      }}
      _active={{
        transform: isDisabled ? "none" : "translateY(4px)",
        boxShadow: "none",
      }}
      transition="all 0.2s"
      opacity={isDisabled ? 0.5 : 1}
      cursor={isDisabled ? "not-allowed" : "pointer"}
      isDisabled={isDisabled}
      {...props}
    >
      {children}
    </Button>
  );
};

const TableHeader = ({ children, onClick, isSortable, sortDirection }) => {
  const { colorMode } = useColorMode();
  
  return (
    <Flex
      alignItems="center"
      justifyContent="center"
      cursor={isSortable ? "pointer" : "default"}
      onClick={onClick}
    >
      <Text
        fontFamily="Karla Variable"
        fontWeight={700}
        fontSize="12px"
        lineHeight="16px"
        color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
        textTransform="uppercase"
        textAlign="center"
      >
        {children}
      </Text>
      {isSortable && (
        <Box marginLeft={1} color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}>
          {sortDirection === "asc" ? (
            <PiSortAscending size={16} />
          ) : (
            <PiSortDescending size={16} />
          )}
        </Box>
      )}
    </Flex>
  );
};

// First let's modify TableCell component
const TableCell = ({ children, isLink, examId, ...props }) => {
  const navigate = useNavigate();
  const { colorMode } = useColorMode();

  if (isLink) {
    return (
      <Text
        fontFamily="Karla Variable"
        fontWeight={700}
        fontSize="12px"
        lineHeight="16px"
        color={colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"}
        textAlign="center"
        cursor="pointer"
        _hover={{
          textDecoration: "underline",
          color: colorMode === 'light' ? "brand.primary.dark" : "brand.primary.light",
        }}
        onClick={(e) => {
          e.stopPropagation();
          navigate(`/actual-exam/${examId}`);
        }}
        {...props}
      >
        {children}
      </Text>
    );
  }

  return (
    <Text
      fontFamily="Karla Variable"
      fontWeight={700}
      fontSize="12px"
      lineHeight="16px"
      color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
      textAlign="center"
      {...props}
    >
      {children}
    </Text>
  );
};

// Modified StatusBadge to support dark mode gradients
const StatusBadge = ({ status }) => {
  const { colorMode } = useColorMode();
  let bgGradient;
  let textColor = colorMode === 'light' ? "brand.text.light" : "brand.text.dark";
  
  switch (status) {
    case "Passed":
      bgGradient = colorMode === 'light'
        ? "linear(to-r, #4CAF50, #8BC34A)"  // Light mode: Bright green gradient
        : "linear(to-r, #2E673F, #4A6F2E)"; // Dark mode: Darker green gradient
      break;
    case "Failed":
      bgGradient = colorMode === 'light'
        ? "linear(to-r, #FF5252, #FF8A80)"  // Light mode: Bright red gradient
        : "linear(to-r, #992F2F, #994D4D)"; // Dark mode: Darker red gradient
      break;
    case "Not Attempted":
      bgGradient = colorMode === 'light'
        ? "linear(to-r, #9E9E9E, #BDBDBD)"  // Light mode: Grey gradient
        : "linear(to-r, #4A4A4A, #666666)"; // Dark mode: Darker grey gradient
      break;
    default:
      bgGradient = colorMode === 'light'
        ? "linear(to-r, #FFD54F, #FFF176)"  // Light mode: Bright yellow gradient
        : "linear(to-r, #997F30, #998E47)"; // Dark mode: Darker yellow gradient
  }
  
  return (
    <Box
      paddingLeft={2}
      paddingRight={2}
      paddingTop={0}
      paddingBottom={0}
      borderRadius="full"
      display="inline-block"
      alignSelf="center"
      border="1px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      bgGradient={bgGradient}
    >
      <Text fontSize="14px" fontWeight="500" color={textColor}>
        {status}
      </Text>
    </Box>
  );
};

// Modified CustomProgressIndicator with theme colors
const CustomProgressIndicator = ({ value }) => {
  const { colorMode } = useColorMode();
  
  const getColor = (value) => {
    if (value < 50) return colorMode === 'light' 
      ? "gradient.error.light"
      : "gradient.error.dark";
    if (value < 75) return colorMode === 'light'
      ? "gradient.warning.light"
      : "gradient.warning.dark";
    return colorMode === 'light'
      ? "gradient.success.light"
      : "gradient.success.dark";
  };

  // The gradient colors based on the theme
  const getGradientColors = (gradientKey) => {
    const gradients = {
      'gradient.error.light': ['#FF5252', '#FF8A80'],
      'gradient.error.dark': ['#992F2F', '#994D4D'],
      'gradient.warning.light': ['#FFD54F', '#FFF176'],
      'gradient.warning.dark': ['#997F30', '#998E47'],
      'gradient.success.light': ['#4CAF50', '#8BC34A'],
      'gradient.success.dark': ['#2E673F', '#4A6F2E']
    };
    
    return gradients[gradientKey] || gradients['gradient.success.light'];
  };

  const gradientColors = getGradientColors(getColor(value));

  return (
    <Box position="relative" width="50px" height="50px">
      <Box
        position="absolute"
        top="0"
        left="0"
        width="100%"
        height="100%"
        borderRadius="50%"
        border="4px solid"
        borderColor={colorMode === 'light' ? "#E0E0E0" : "#404040"}
      />
      <Box
        as="svg"
        viewBox="0 0 36 36"
        width="100%"
        height="100%"
        position="absolute"
      >
        <defs>
          <linearGradient
            id={`gradient-${value}`}
            gradientTransform="rotate(90)"
          >
            <stop offset="0%" stopColor={gradientColors[0]} />
            <stop offset="100%" stopColor={gradientColors[1]} />
          </linearGradient>
        </defs>
        <path
          d={`M18 2.0845
            a 15.9155 15.9155 0 0 1 0 31.831
            a 15.9155 15.9155 0 0 1 0 -31.831`}
          fill="none"
          stroke={`url(#gradient-${value})`}
          strokeWidth="4"
          strokeDasharray={`${value}, 100`}
        />
      </Box>
      <Flex
        position="absolute"
        top="0"
        left="0"
        width="100%"
        height="100%"
        alignItems="center"
        justifyContent="center"
      >
        <Text 
          fontSize="12px" 
          fontWeight="bold"
          color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
        >
          {value}%
        </Text>
      </Flex>
    </Box>
  );
};

const ProviderGroup = ({
  provider,
  exams,
  selectedRows,
  handleSelectRow,
  handleSort,
}) => {
  const [isOpen, setIsOpen] = useState(true);
  const { colorMode } = useColorMode();

  const allProviderExamsSelected = useMemo(() => {
    const providerExamIds = exams.map((exam) => exam.id);
    return providerExamIds.every((id) => selectedRows.includes(id));
  }, [exams, selectedRows]);

  const someProviderExamsSelected = useMemo(() => {
    const providerExamIds = exams.map((exam) => exam.id);
    return (
      providerExamIds.some((id) => selectedRows.includes(id)) &&
      !allProviderExamsSelected
    );
  }, [exams, selectedRows, allProviderExamsSelected]);

  const toggleGroup = (e) => {
    e.stopPropagation();
    setIsOpen(!isOpen);
  };

  const handleProviderSelect = (e) => {
    e.stopPropagation();
    const providerExamIds = exams.map((exam) => exam.id);

    if (allProviderExamsSelected) {
      handleSelectRow(providerExamIds, false);
    } else {
      handleSelectRow(providerExamIds, true);
    }
  };

  const formatNumber = (number, decimals = 2) => {
    if (number === null || number === undefined) return "0.00";
    return Number(number).toFixed(decimals);
  };

  return (
    <Box
      width="100%"
      backgroundColor={colorMode === 'light' ? "brand.surface.light" : "brand.surface.dark"}
      borderRadius="10px"
      border="1px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      position="relative"
      overflow="hidden"
    >
      <Flex
        justifyContent="space-between"
        alignItems="center"
        padding={4}
        backgroundColor={colorMode === 'light' ? "brand.secondary.light" : "brand.secondary.dark"}
        _hover={{ 
          backgroundColor: colorMode === 'light' 
            ? "rgba(179, 235, 242, 0.8)" 
            : "rgba(38, 94, 109, 0.8)" 
        }}
        cursor="pointer"
        onClick={toggleGroup}
      >
        <Flex alignItems="center" flex={1}>
          <Box
            width="40px"
            textAlign="center"
            onClick={(e) => e.stopPropagation()}
          >
            <CustomCheckbox
              isChecked={allProviderExamsSelected}
              isIndeterminate={someProviderExamsSelected}
              onChange={handleProviderSelect}
            />
          </Box>
          <Text 
            fontSize="18px" 
            fontWeight="700" 
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
            flex={1}
          >
            {provider}
          </Text>
        </Flex>
        <Box color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}>
          {isOpen ? <IoChevronUp size={20} /> : <IoChevronDown size={20} />}
        </Box>
      </Flex>
      <AnimatePresence initial={false}>
        {isOpen && (
          <motion.div
            initial={{ height: 0 }}
            animate={{ height: "auto" }}
            exit={{ height: 0 }}
            transition={{ duration: 0.3 }}
            style={{ overflow: "hidden" }}
          >
            <VStack spacing={0} align="stretch">
              {exams.map((item, index) => (
                <Flex
                  key={item.id}
                  borderTop={index === 0 
                    ? `1px solid ${colorMode === 'light' 
                      ? "rgba(226, 232, 240, 0.8)" 
                      : "rgba(64, 64, 64, 0.8)"}`
                    : "none"
                  }
                  borderBottom={`1px solid ${colorMode === 'light'
                    ? "rgba(226, 232, 240, 0.8)"
                    : "rgba(64, 64, 64, 0.8)"}`
                  }
                  padding={4}
                  backgroundColor={colorMode === 'light' ? "brand.background.light" : "brand.background.dark"}
                  _hover={{ 
                    backgroundColor: colorMode === 'light' 
                      ? "brand.surface.light" 
                      : "brand.surface.dark" 
                  }}
                  transition="background-color 0.2s"
                  alignItems="center"
                >
                  <Box width="40px" textAlign="center">
                    <CustomCheckbox
                      isChecked={selectedRows.includes(item.id)}
                      onChange={() =>
                        handleSelectRow(
                          [item.id],
                          !selectedRows.includes(item.id)
                        )
                      }
                    />
                  </Box>
                  <Box flex={1}>
                    <TableCell isLink examId={item.id}>
                      {item.exam || "Untitled Exam"}
                    </TableCell>
                  </Box>
                  <Box flex={1}>
                    <TableCell>{item.examType || "Actual"}</TableCell>
                  </Box>
                  <Box flex={1}>
                    <TableCell>
                      Attempt {item.attempts || 0}
                      <br />
                      Avg: {formatNumber(item.averageScore)}%
                    </TableCell>
                  </Box>
                  <Box flex={1} display="flex" justifyContent="center">
                    <CustomProgressIndicator value={item.progress || 0} />
                  </Box>
                  <Box flex={1}>
                    <Flex direction="column" alignItems="center">
                      <TableCell>
                        {`${item.latestGrade?.score || 0}/${
                          item.latestGrade?.total || 100
                        }`}
                      </TableCell>
                      <Box marginTop={1}>
                        <StatusBadge status={item.status || "Not Attempted"} />
                      </Box>
                    </Flex>
                  </Box>
                  <Box flex={1}>
                    <TableCell>{item.updated || "Not started"}</TableCell>
                  </Box>
                </Flex>
              ))}
            </VStack>
          </motion.div>
        )}
      </AnimatePresence>
    </Box>
  );
};

const CustomDashboardTableComponent = ({
  data,
  onDeleteSelected,
  onDeleteAll,
}) => {
  const [selectedRows, setSelectedRows] = useState([]);
  const [selectAll, setSelectAll] = useState(false);
  const [sortConfig, setSortConfig] = useState({
    key: "updated",
    direction: "desc",
  });
  const [currentPage, setCurrentPage] = useState(1);
  const [searchTerm, setSearchTerm] = useState("");
  const { colorMode } = useColorMode();
  const itemsPerPage = 2;

  const handleSelectAll = () => {
    const allIds = data.flatMap((provider) =>
      provider.exams.map((exam) => exam.id)
    );

    if (selectAll) {
      setSelectedRows([]);
    } else {
      setSelectedRows(allIds);
    }
    setSelectAll(!selectAll);
  };

  const handleSort = (key) => {
    let direction = "asc";
    if (sortConfig.key === key && sortConfig.direction === "asc") {
      direction = "desc";
    }
    setSortConfig({ key, direction });
  };

  const handleSelectRow = (ids, isSelected) => {
    setSelectedRows((prev) => {
      if (Array.isArray(ids)) {
        if (isSelected) {
          const newSelection = [...new Set([...prev, ...ids])];
          const allPossibleIds = data.flatMap((provider) =>
            provider.exams.map((exam) => exam.id)
          );
          setSelectAll(newSelection.length === allPossibleIds.length);
          return newSelection;
        } else {
          const newSelection = prev.filter((id) => !ids.includes(id));
          setSelectAll(false);
          return newSelection;
        }
      } else {
        const newSelection = prev.includes(ids)
          ? prev.filter((id) => id !== ids)
          : [...prev, ids];

        const allPossibleIds = data.flatMap((provider) =>
          provider.exams.map((exam) => exam.id)
        );
        setSelectAll(newSelection.length === allPossibleIds.length);
        return newSelection;
      }
    });
  };

  const processedData = useMemo(() => {
    // Flatten the provider structure
    const flattenedData = data.flatMap((provider) =>
      provider.exams.map((exam) => ({
        ...exam,
        provider: provider.name,
      }))
    );

    // Sort the data
    let sortedData = [...flattenedData];
    if (sortConfig.key) {
      sortedData.sort((a, b) => {
        if (sortConfig.key === "updated") {
          // Sort by timestamp for 'updated' column
          const aTime = new Date(a.timestamp || 0).getTime();
          const bTime = new Date(b.timestamp || 0).getTime();
          return sortConfig.direction === "asc" ? aTime - bTime : bTime - aTime;
        }

        if (a[sortConfig.key] < b[sortConfig.key]) {
          return sortConfig.direction === "asc" ? -1 : 1;
        }
        if (a[sortConfig.key] > b[sortConfig.key]) {
          return sortConfig.direction === "asc" ? 1 : -1;
        }
        return 0;
      });
    }

    // Filter based on search term
    const filteredData = sortedData.filter(
      (item) =>
        item.exam.toLowerCase().includes(searchTerm.toLowerCase()) ||
        item.provider.toLowerCase().includes(searchTerm.toLowerCase())
    );

    // Group by provider
    return filteredData.reduce((acc, item) => {
      if (!acc[item.provider]) {
        acc[item.provider] = [];
      }
      acc[item.provider].push(item);
      return acc;
    }, {});
  }, [data, sortConfig, searchTerm]);

  const providerList = Object.keys(processedData);
  const totalPages = Math.ceil(providerList.length / itemsPerPage);
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  const paginatedProviderList = providerList.slice(startIndex, endIndex);

  return (
    <Box
      borderRadius="12px"
      border="1px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      padding={6}
      overflowY="scroll"
      maxHeight="600px"
      backgroundColor={colorMode === 'light' ? "brand.background.light" : "brand.background.dark"}
    >
      <Flex justifyContent="space-between" alignItems="center" marginBottom={4}>
        <Text
          fontFamily="Karla Variable"
          fontWeight={700}
          fontSize="16px"
          lineHeight="24px"
          color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
        >
          Your Exam Progress
        </Text>
        <Flex>
          <Input
            placeholder="Search exams..."
            size="md"
            width="250px"
            marginRight={4}
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            backgroundColor={colorMode === 'light' ? "brand.background.light" : "brand.background.dark"}
            borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
            _placeholder={{
              color: colorMode === 'light' 
                ? "rgba(0, 0, 0, 0.5)" 
                : "rgba(255, 255, 255, 0.5)"
            }}
          />
          <CustomButton
            onClick={() => onDeleteSelected(selectedRows)}
            backgroundColor="transparent"
            hoverBackgroundColor={colorMode === 'light' ? "#FFE5E5" : "#4D0000"}
            borderColor={colorMode === 'light' ? "#FF3333" : "#FF6666"}
            marginRight={4}
            isDisabled={selectedRows.length === 0}
          >
            Delete Selected
          </CustomButton>
          <CustomButton
            onClick={onDeleteAll}
            backgroundColor={colorMode === 'light' ? "#FF3333" : "#FF6666"}
            hoverBackgroundColor={colorMode === 'light' ? "#FF0000" : "#CC0000"}
          >
            Delete All
          </CustomButton>
        </Flex>
      </Flex>
      <Box
        borderRadius="12px"
        border="1px solid"
        borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
        boxShadow={colorMode === 'light' 
          ? "0 4px 0 0 black" 
          : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
        }
        overflow="hidden"
      >
        <Box overflowX="auto">
          <Box minWidth="1200px">
            {/* Table Header */}
            <Flex
              backgroundColor={colorMode === 'light' ? "brand.surface.light" : "brand.surface.dark"}
              borderBottom="1px solid"
              borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
              padding={4}
              alignItems="center"
            >
              <Box width="40px" textAlign="center">
                <CustomCheckbox
                  isChecked={selectAll}
                  onChange={handleSelectAll}
                />
              </Box>
              <Box flex={1}>
                <TableHeader>Exam</TableHeader>
              </Box>
              <Box flex={1}>
                <TableHeader>Type</TableHeader>
              </Box>
              <Box flex={1}>
                <TableHeader>Attempts</TableHeader>
              </Box>
              <Box flex={1}>
                <TableHeader>Progress</TableHeader>
              </Box>
              <Box flex={1}>
                <TableHeader>Latest Grade</TableHeader>
              </Box>
              <Box flex={1}>
                <TableHeader
                  isSortable
                  onClick={() => handleSort("updated")}
                  sortDirection={
                    sortConfig.key === "updated"
                      ? sortConfig.direction
                      : undefined
                  }
                >
                  Updated
                </TableHeader>
              </Box>
            </Flex>

            {/* Table Body */}
            {paginatedProviderList.map((provider) => (
              <ProviderGroup
                key={provider}
                provider={provider}
                exams={processedData[provider]}
                selectedRows={selectedRows}
                handleSelectRow={handleSelectRow}
                handleSort={handleSort}
              />
            ))}
          </Box>
        </Box>
      </Box>

      {/* Pagination */}
      <Box 
        marginTop={4}
        backgroundColor={colorMode === 'light' ? "brand.background.light" : "brand.background.dark"}
      >
        <Pagination
          currentPage={currentPage}
          totalPages={totalPages}
          onPageChange={setCurrentPage}
        />
      </Box>
    </Box>
  );
};

const CustomDashboardTable = React.memo(CustomDashboardTableComponent);
export default CustomDashboardTable;
----
CustomToast.js
import React from 'react';
import { Box, Text, Flex, useColorMode } from '@chakra-ui/react';
import { motion, AnimatePresence } from 'framer-motion';
import { FaCheck, FaExclamationTriangle, FaTimes } from 'react-icons/fa';

const CustomToast = ({ 
  title, 
  description, 
  status = 'success', 
  onClose,
  id 
}) => {
  const { colorMode } = useColorMode();

  const getStatusStyles = () => {
    const styles = {
      success: {
        light: {
          bg: 'linear-gradient(to right, #4CAF50, #8BC34A)',
          iconColor: 'white',
          textColor: 'black'
        },
        dark: {
          bg: 'linear-gradient(to right, #2E673F, #4A6F2E)',
          iconColor: 'white',
          textColor: 'white'
        }
      },
      error: {
        light: {
          bg: 'linear-gradient(to right, #FF5252, #FF8A80)',
          iconColor: 'white',
          textColor: 'black'
        },
        dark: {
          bg: 'linear-gradient(to right, #992F2F, #994D4D)',
          iconColor: 'white',
          textColor: 'white'
        }
      },
      warning: {
        light: {
          bg: 'linear-gradient(to right, #FFD54F, #FFF176)',
          iconColor: 'black',
          textColor: 'black'
        },
        dark: {
          bg: 'linear-gradient(to right, #997F30, #998E47)',
          iconColor: 'white',
          textColor: 'white'
        }
      }
    };

    const currentMode = colorMode === 'light' ? 'light' : 'dark';
    const statusStyle = styles[status] || styles.success;

    return {
      bg: statusStyle[currentMode].bg,
      icon: status === 'error' ? FaExclamationTriangle : FaCheck,
      iconColor: statusStyle[currentMode].iconColor,
      textColor: statusStyle[currentMode].textColor
    };
  };

  const { bg, icon: Icon, iconColor, textColor } = getStatusStyles();

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0, y: 50, scale: 0.3 }}
        animate={{ opacity: 1, y: 0, scale: 1 }}
        exit={{ opacity: 0, scale: 0.5, transition: { duration: 0.2 } }}
        style={{ width: '100%', position: 'relative' }}
      >
        <Box
          width="100%"
          bgGradient={bg}
          borderRadius="12px"
          border="1px solid"
          borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
          boxShadow={colorMode === 'light'
            ? "0 4px 0 0 black"
            : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
          }
          padding={4}
          position="relative"
        >
          <Flex alignItems="center">
            <Box
              borderRadius="full"
              bg={colorMode === 'light' 
                ? "rgba(255, 255, 255, 0.2)"
                : "rgba(255, 255, 255, 0.1)"
              }
              p={2}
              mr={3}
            >
              <Icon size={24} color={iconColor} />
            </Box>
            <Box flex="1">
              <Text
                fontSize="16px"
                fontWeight="700"
                color={textColor}
                mb={description ? 1 : 0}
              >
                {title}
              </Text>
              {description && (
                <Text 
                  fontSize="14px" 
                  color={textColor}
                  opacity={0.8}
                >
                  {description}
                </Text>
              )}
            </Box>
            <Box
              as="button"
              onClick={() => onClose(id)}
              color={textColor}
              p={2}
              borderRadius="md"
              _hover={{ bg: 'transparent' }}
              display="flex"
              alignItems="center"
              justifyContent="center"
            >
              <FaTimes size={16} />
            </Box>
          </Flex>
        </Box>
      </motion.div>
    </AnimatePresence>
  );
};

// Custom toast function to be used with Chakra's useToast
export const createCustomToast = (toast) => {
  return ({
    title,
    description,
    status = 'success',
    duration = 5000,
    isClosable = true,
  }) => {
    toast({
      position: 'bottom-right',
      render: ({ onClose, id }) => (
        <CustomToast
          title={title}
          description={description}
          status={status}
          onClose={onClose}
          id={id}
        />
      ),
      duration,
      isClosable,
    });
  };
};

export default CustomToast;
----
Dashboard.js
import React, { useState, useEffect, useRef, useCallback } from "react";
import {
  Box,
  Flex,
  Text,
  Button,
  VStack,
  useToast,
  Spinner,
  useDisclosure,
  useColorMode,
} from "@chakra-ui/react";
import { FaApple, FaAndroid, FaHeart, FaTimes } from "react-icons/fa";
import CustomDashboardTable from "./CustomDashboardTable";
import DeleteConfirmationModal from "./DeleteConfirmationModal";
import { createCustomToast } from "./CustomToast";

const WelcomeComponent = ({ users, countries }) => {
  const { colorMode } = useColorMode();
  
  return (
    <Box
      width="100%"
      bgGradient="linear(to-r, #00bfff, #0080ff)"  // Keeping original gradient
      borderRadius={{ base: "10px", md: "20px" }}
      border="1px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      boxShadow={colorMode === 'light' 
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"}
      padding={{ base: 4, md: 6 }}
      marginBottom={{ base: 4, md: 8 }}
      position="relative"
      overflow="hidden"
    >
      <Box
        position="absolute"
        top={{ base: "-10px", md: "-20px" }}
        right={{ base: "-10px", md: "-20px" }}
        width={{ base: "100px", md: "150px" }}
        height={{ base: "100px", md: "150px" }}
        borderRadius="full"
        backgroundColor="rgba(255, 255, 255, 0.1)"
      />
      <Flex
        justifyContent="space-between"
        alignItems="center"
        flexDirection={{ base: "column", md: "row" }}
      >
        <VStack
          align={{ base: "center", md: "flex-start" }}
          spacing={2}
          marginBottom={{ base: 4, md: 0 }}
        >
          <Text
            fontSize={{ base: "24px", md: "32px" }}
            fontWeight="800"
            color="white"
            textAlign={{ base: "center", md: "left" }}
          >
            Welcome to Hiraya
          </Text>
          <Text
            fontSize={{ base: "16px", md: "18px" }}
            fontWeight="500"
            color="white"
            textAlign={{ base: "center", md: "left" }}
          >
            Empowering your learning journey
          </Text>
        </VStack>
        <Flex>
          <Box marginRight={{ base: 4, md: 8 }} textAlign="center">
            <Text
              fontSize={{ base: "32px", md: "40px" }}
              fontWeight="800"
              color="white"
            >
              {users}M+
            </Text>
            <Text
              fontSize={{ base: "14px", md: "16px" }}
              fontWeight="600"
              color="white"
            >
              Users
            </Text>
          </Box>
          <Box textAlign="center">
            <Text
              fontSize={{ base: "32px", md: "40px" }}
              fontWeight="800"
              color="white"
            >
              {countries}+
            </Text>
            <Text
              fontSize={{ base: "14px", md: "16px" }}
              fontWeight="600"
              color="white"
            >
              Countries
            </Text>
          </Box>
        </Flex>
      </Flex>
    </Box>
  );
};

const CustomButton = ({
  children,
  leftIcon,
  backgroundColor,
  color,
  _hover,
  boxShadow,
  ...props
}) => (
  <Button
    height="48px"
    fontSize={{ base: "14px", md: "16px" }}
    paddingLeft={{ base: "16px", md: "24px" }}
    paddingRight={{ base: "16px", md: "24px" }}
    backgroundColor={backgroundColor || "white"}
    color={color || "black"}
    borderRadius="full"
    border="1px solid black"
    fontWeight={700}
    textTransform="uppercase"
    transition="0.3s"
    boxShadow={boxShadow || "0 4px 0 0 black"}
    _hover={{
      transform: "translateY(2px)",
      boxShadow: "0 2px 0 0 black",
      ..._hover,
    }}
    _active={{
      transform: "translateY(4px)",
      boxShadow: "none",
    }}
    leftIcon={leftIcon}
    {...props}
  >
    {children}
  </Button>
);

const CloseButton = ({ onClick }) => {
  const { colorMode } = useColorMode();

  return (
    <Box
      as="button"
      onClick={onClick}
      display="inline-flex"
      alignItems="center"
      justifyContent="center"
      w="24px"
      h="24px"
      bg="transparent"
      _focus={{ boxShadow: "none" }}
      color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
      borderRadius="50%"
    >
      <FaTimes size="16px" />
    </Box>
  );
};

const MobileAppsComing = ({ onClose }) => {
  const { colorMode } = useColorMode();

  return (
    <Box
      width="100%"
      bgGradient={
        colorMode === "light"
          ? "linear(to-br, #FFB347, #ffcc33)"
          : "linear(to-br, #B37F32, #B38F24)"
      }
      borderRadius={{ base: "10px", md: "20px" }}
      border="1px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      boxShadow={colorMode === 'light' 
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"}
      padding={{ base: 4, md: 6 }}
      marginBottom={{ base: 4, md: 8 }}
      position="relative"
      overflow="hidden"
    >
      <Box position="absolute" top={2} right={2} zIndex={1}>
        <CloseButton onClick={onClose} />
      </Box>
      <Box
        position="absolute"
        bottom={{ base: "-15px", md: "-30px" }}
        left={{ base: "-15px", md: "-30px" }}
        width={{ base: "100px", md: "150px" }}
        height={{ base: "100px", md: "150px" }}
        borderRadius="full"
        backgroundColor="rgba(255, 255, 255, 0.1)"
      />
      <Flex
        justifyContent="space-between"
        alignItems="center"
        flexDirection={{ base: "column", md: "row" }}
      >
        <VStack
          align={{ base: "center", md: "flex-start" }}
          spacing={2}
          marginBottom={{ base: 4, md: 0 }}
        >
          <Text
            fontSize={{ base: "24px", md: "28px" }}
            fontWeight="800"
            color="black"
            textAlign={{ base: "center", md: "left" }}
          >
            Mobile Apps Coming Soon
          </Text>
          <Text
            fontSize={{ base: "16px", md: "18px" }}
            fontWeight="500"
            color="black"
            textAlign={{ base: "center", md: "left" }}
          >
            Your learning journey, now in your pocket!
          </Text>
        </VStack>
        <Flex
          flexDirection={{ base: "column", sm: "row" }}
          marginTop={{ base: 4, md: 0 }}
        >
          <CustomButton
            leftIcon={<FaApple />}
            marginBottom={{ base: 2, sm: 0 }}
            marginRight={{ base: 0, sm: 4 }}
            backgroundColor="white"
            color="black"
            border="1px solid black"
            boxShadow="0 4px 0 0 black"
            _hover={{
              transform: "translateY(2px)",
              boxShadow: "0 2px 0 0 black",
            }}
            _active={{
              transform: "translateY(4px)",
              boxShadow: "none",
            }}
          >
            iOS
          </CustomButton>
          <CustomButton
            leftIcon={<FaAndroid />}
            backgroundColor="white"
            color="black"
            border="1px solid black"
            boxShadow="0 4px 0 0 black"
            _hover={{
              transform: "translateY(2px)",
              boxShadow: "0 2px 0 0 black",
            }}
            _active={{
              transform: "translateY(4px)",
              boxShadow: "none",
            }}
          >
            Android
          </CustomButton>
        </Flex>
      </Flex>
    </Box>
  );
};

const SupportDevelopers = ({ onClose }) => {
  const { colorMode } = useColorMode();
  
  return (
    <Box
      width="100%"
      bgGradient="linear(to-r, #8BC34A, #4CAF50)"
      borderRadius={{ base: "10px", md: "20px" }}
      border="1px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      boxShadow={colorMode === 'light' 
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"}
      padding={{ base: 4, md: 6 }}
      marginBottom={{ base: 4, md: 8 }}
      position="relative"
      overflow="hidden"
    >
      <Box position="absolute" top={2} right={2} zIndex={1}>
        <CloseButton onClick={onClose} />
      </Box>
      <Box
        position="absolute"
        top={{ base: "-15px", md: "-30px" }}
        right={{ base: "-15px", md: "-30px" }}
        width={{ base: "100px", md: "150px" }}
        height={{ base: "100px", md: "150px" }}
        borderRadius="full"
        backgroundColor="rgba(255, 255, 255, 0.1)"
      />
      <Flex
        justifyContent="space-between"
        alignItems="center"
        flexDirection={{ base: "column", md: "row" }}
      >
        <VStack 
          align={{ base: "center", md: "flex-start" }} 
          spacing={2} 
          flex="1"
        >
          <Text
            fontSize={{ base: "24px", md: "28px" }}
            fontWeight="800"
            color="white"
            textAlign={{ base: "center", md: "left" }}
          >
            Support the Developers
          </Text>
          <Text
            fontSize={{ base: "16px", md: "18px" }}
            fontWeight="500"
            color="white"
            textAlign={{ base: "center", md: "left" }}
          >
            Help us keep Hiraya ad-free and running 24/7, 365 days a year
          </Text>
          <Text
            fontSize={{ base: "14px", md: "16px" }}
            fontWeight="500"
            color="white"
            textAlign={{ base: "center", md: "left" }}
          >
            Your support helps cover recurring costs and keeps this website
            ad-free. Thank you for your generosity!
          </Text>
        </VStack>
        <Box marginLeft={{ base: 0, md: 4 }} marginTop={{ base: 4, md: 0 }}>
          <CustomButton
            leftIcon={<FaHeart />}
            backgroundColor="#FF4081"
            color="white"
            border="1px solid black"
            boxShadow="0 4px 0 0 black"
            _hover={{
              backgroundColor: "#E91E63",
              transform: "translateY(2px)",
              boxShadow: "0 2px 0 0 black",
            }}
            _active={{
              transform: "translateY(4px)",
              boxShadow: "none",
            }}
          >
            DONATE
          </CustomButton>
        </Box>
      </Flex>
    </Box>
  );
};

const EmptyProgressState = () => {
  const { colorMode } = useColorMode();
  
  return (
    <Box
      borderRadius="12px"
      border="1px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      padding={6}
      backgroundColor={colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"}
      marginBottom={8}
      boxShadow={colorMode === 'light' 
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
      }
    >
      <VStack spacing={4}>
        <Text 
          fontSize="xl" 
          fontWeight="bold" 
          textAlign="center"
          color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
        >
          No Exam Progress Yet
        </Text>
        <Text 
          color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
          opacity={0.6}
          textAlign="center"
        >
          Start your learning journey by selecting an exam and clicking "Continue"
          to begin tracking your progress here.
        </Text>
      </VStack>
    </Box>
  );
};

const Dashboard = () => {
  // State declarations
  const [showMobileApps, setShowMobileApps] = useState(true);
  const [showSupport, setShowSupport] = useState(true);
  const [examProgress, setExamProgress] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [selectedForDeletion, setSelectedForDeletion] = useState([]);
  const [deleteType, setDeleteType] = useState("");

  // Refs for cleanup and preventing memory leaks
  const abortControllerRef = useRef(null);
  const isMounted = useRef(true);

  // Hooks
  const toast = useToast();
  const toastRef = useRef(createCustomToast(toast));
  const {
    isOpen: isDeleteModalOpen,
    onOpen: openDeleteModal,
    onClose: closeDeleteModal,
  } = useDisclosure();

  // Fetch exam progress with cleanup and error handling
  const fetchExamProgress = useCallback(async () => {
    // Cancel any ongoing requests
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    // Create new abort controller
    abortControllerRef.current = new AbortController();

    try {
      if (!isMounted.current) return;
      setIsLoading(true);

      const response = await fetch("http://localhost:5000/api/exam-progress", {
        signal: abortControllerRef.current.signal,
      });

      if (!response.ok) {
        throw new Error("Failed to fetch exam progress");
      }

      const data = await response.json();
      if (isMounted.current) {
        setExamProgress(data.providers);
      }
    } catch (error) {
      if (error.name === "AbortError") {
        return; // Ignore abort errors
      }

      console.error("Error fetching exam progress:", error);
      if (isMounted.current) {
        toastRef.current({
          title: "Error fetching exam progress",
          description: error.message,
          status: "error",
        });
        setExamProgress([]);
      }
    } finally {
      if (isMounted.current) {
        setIsLoading(false);
      }
    }
  }, []); // No dependencies needed since we use refs

  // Setup effect
  useEffect(() => {
    isMounted.current = true;
    fetchExamProgress();

    // Cleanup function
    return () => {
      isMounted.current = false;
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [fetchExamProgress]);

  // Handler for deleting selected items
  const handleDeleteSelected = useCallback(
    async (selectedIds) => {
      setSelectedForDeletion(selectedIds);
      setDeleteType("selected");
      openDeleteModal();
    },
    [openDeleteModal]
  );

  // Handler for deleting all items
  const handleDeleteAll = useCallback(() => {
    setDeleteType("all");
    openDeleteModal();
  }, [openDeleteModal]);

  // Confirm delete handler
  const handleConfirmDelete = async () => {
    try {
      if (deleteType === "all") {
        await fetch("http://localhost:5000/api/delete-all-progress", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
        });

        if (isMounted.current) {
          setExamProgress([]);
          toastRef.current({
            title: "All progress cleared",
            description: "Your exam progress history has been cleared.",
            status: "success",
          });
        }
      } else {
        const providerGroups = examProgress.reduce(
          (acc, provider) => {
            const selectedProviderExams = provider.exams
              .filter((exam) => selectedForDeletion.includes(exam.id))
              .map((exam) => exam.id);

            if (selectedProviderExams.length === provider.exams.length) {
              acc.providers.push(provider.name);
            } else if (selectedProviderExams.length > 0) {
              acc.exams.push(...selectedProviderExams);
            }
            return acc;
          },
          { providers: [], exams: [] }
        );

        // Delete providers if needed
        if (providerGroups.providers.length > 0) {
          await fetch("http://localhost:5000/api/delete-provider-exams", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ provider_names: providerGroups.providers }),
          });
        }

        // Delete individual exams if needed
        if (providerGroups.exams.length > 0) {
          await fetch("http://localhost:5000/api/delete-exams", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ exam_ids: providerGroups.exams }),
          });
        }

        // Refresh data
        await fetchExamProgress();

        if (isMounted.current) {
          toastRef.current({
            title: "Selected items deleted",
            description:
              "The selected exams have been removed from your progress tracking.",
            status: "success",
          });
        }
      }
    } catch (error) {
      console.error("Error during deletion:", error);
      if (isMounted.current) {
        toastRef.current({
          title: "Error",
          description: `Failed to delete ${
            deleteType === "all" ? "all progress" : "selected items"
          }`,
          status: "error",
        });
      }
    } finally {
      if (isMounted.current) {
        closeDeleteModal();
        setSelectedForDeletion([]);
      }
    }
  };

  // Render JSX
  return (
    <Box
      width="100%"
      paddingLeft={{ base: 2, sm: 4, md: 6, lg: 8 }}
      paddingRight={{ base: 2, sm: 4, md: 6, lg: 8 }}
    >
      <WelcomeComponent users={2.0} countries={190} />

      {showMobileApps && (
        <MobileAppsComing onClose={() => setShowMobileApps(false)} />
      )}

      {showSupport && (
        <SupportDevelopers onClose={() => setShowSupport(false)} />
      )}

      {isLoading ? (
        <Flex justify="center" align="center" height="400px">
          <Spinner size="xl" color="#00bfff" thickness="4px" />
        </Flex>
      ) : examProgress.length === 0 ? (
        <EmptyProgressState />
      ) : (
        <CustomDashboardTable
          data={examProgress}
          onDeleteSelected={handleDeleteSelected}
          onDeleteAll={handleDeleteAll}
        />
      )}

      <DeleteConfirmationModal
        isOpen={isDeleteModalOpen}
        onClose={closeDeleteModal}
        onConfirm={handleConfirmDelete}
        deleteType={deleteType}
        itemCount={selectedForDeletion.length}
        title={
          deleteType === "all"
            ? "Delete All Progress"
            : "Delete Selected Progress"
        }
        message={
          deleteType === "all"
            ? undefined
            : `Selected items include ${selectedForDeletion.length} exam${
                selectedForDeletion.length === 1 ? "" : "s"
              }`
        }
      />
    </Box>
  );
};

export default Dashboard;

----
DeleteConfirmationModal.js
import React from 'react';
import {
  Box,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  Button,
  Text,
  Flex,
  VStack,
  useColorMode,
} from '@chakra-ui/react';
import { FaTimes, FaTrash } from 'react-icons/fa';

const CloseButton = ({ onClick, colorMode }) => {
  return (
    <Box
      as="button"
      onClick={onClick}
      display="inline-flex"
      alignItems="center"
      justifyContent="center"
      w="24px"
      h="24px"
      bg="transparent"
      _focus={{ boxShadow: "none" }}
      color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
      borderRadius="50%"
      _hover={{ bg: 'transparent' }} // Ensures no background change on hover
    >
      <FaTimes size="16px" />
    </Box>
  );
};

const CustomButton = ({ children, onClick, isDanger = false, ...props }) => {
  const { colorMode } = useColorMode();

  // For danger buttons, we'll use specific colors rather than theme colors
  const dangerColors = {
    light: {
      bg: "#FF3333",
      hoverBg: "#FF0000",
      text: "white",
    },
    dark: {
      bg: "#CC0000",
      hoverBg: "#990000",
      text: "white",
    },
  };

  return (
    <Button
      onClick={onClick}
      height="48px"
      fontSize="16px"
      px="24px"
      bg={isDanger 
        ? dangerColors[colorMode].bg
        : (colorMode === 'light' ? "brand.background.light" : "brand.surface.dark")
      }
      color={isDanger
        ? dangerColors[colorMode].text
        : (colorMode === 'light' ? "brand.text.light" : "brand.text.dark")
      }
      borderRadius="full"
      border="1px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      fontWeight={700}
      textTransform="uppercase"
      transition="0.3s"
      boxShadow={colorMode === 'light'
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
      }
      _hover={{
        bg: isDanger
          ? dangerColors[colorMode].hoverBg
          : (colorMode === 'light' ? "brand.surface.light" : "brand.background.dark"),
        transform: 'translateY(2px)',
        boxShadow: colorMode === 'light'
          ? "0 2px 0 0 black"
          : "0 2px 0 0 rgba(255, 255, 255, 0.2)",
      }}
      _active={{
        transform: 'translateY(4px)',
        boxShadow: 'none',
      }}
      {...props}
    >
      {children}
    </Button>
  );
};

const DeleteConfirmationModal = ({ 
  isOpen, 
  onClose, 
  onConfirm, 
  title = "Confirm Deletion",
  message,
  itemCount,
  deleteType // "selected" or "all"
}) => {
  const { colorMode } = useColorMode();

  const getDescription = () => {
    if (deleteType === "all") {
      return "This will permanently delete all your exam progress. This action cannot be undone.";
    }
    return `This will permanently delete ${itemCount} ${itemCount === 1 ? 'exam' : 'exams'} and their progress. This action cannot be undone.`;
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} isCentered>
      <ModalOverlay />
      <ModalContent
        borderRadius="20px"
        border="1px solid"
        borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
        boxShadow={colorMode === 'light'
          ? "0 8px 0 0 black"
          : "0 8px 0 0 rgba(255, 255, 255, 0.2)"
        }
        bg={colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"}
        p={6}
      >
        <Flex justifyContent="flex-end">
          <CloseButton onClick={onClose} />
        </Flex>
        <ModalHeader
          fontFamily="heading"
          fontWeight="bold"
          fontSize="24px"
          pb={4}
          color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
        >
          {title}
        </ModalHeader>
        <ModalBody>
          <VStack spacing={4} align="stretch">
            <Text 
              fontFamily="body"
              fontSize="18px"
              color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
            >
              {getDescription()}
            </Text>
            {message && (
              <Text 
                fontFamily="body"
                fontSize="16px"
                color={colorMode === 'light' ? "gray.600" : "gray.400"}
              >
                {message}
              </Text>
            )}
          </VStack>
        </ModalBody>
        <ModalFooter>
          <Flex justifyContent="flex-end" width="100%" gap={4}>
            <CustomButton onClick={onClose}>
              Cancel
            </CustomButton>
            <CustomButton 
              onClick={onConfirm} 
              isDanger
              leftIcon={<FaTrash />}
            >
              Delete {deleteType === "all" ? "All" : "Selected"}
            </CustomButton>
          </Flex>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
};

export default DeleteConfirmationModal;
----
DownloadBox.js
import React from 'react';
import { Box, Text, VStack, useColorMode } from '@chakra-ui/react';
import { FaFileDownload, FaChevronRight } from "react-icons/fa";

const DownloadBox = () => {
  const { colorMode } = useColorMode();

  const premiumGradients = {
    light: {
      normal: "linear(to-r, #ffaa40, #9c40ff, #ffaa40)",
      hover: "linear(to-r, #ff9020, #7c20ff, #ff9020)",
    },
    dark: {
      normal: "linear(to-r, #cc7718, #7718cc, #cc7718)",
      hover: "linear(to-r, #b35f0f, #5f0fb3, #b35f0f)",
    }
  };

  return (
    <Box position="relative" width="100%" maxWidth="2xl" mx="auto">
      <Box
        width="100%"
        height="auto"
        py={12}
        bg={colorMode === 'light' ? 'gray.100' : 'gray.800'}
        borderRadius="20px"
        border="1px solid"
        borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
        boxShadow={colorMode === 'light'
          ? "0 4px 0 0 black"
          : "0 4px 0 0 rgba(255, 255, 255, 0.2)"}
        position="relative"
        overflow="hidden"
        display="flex"
        justifyContent="center"
        alignItems="center"
        cursor="not-allowed"
      >
        <VStack 
          spacing={2} 
          color={colorMode === 'light' ? 'gray.500' : 'gray.400'} 
          textAlign="center"
        >
          <FaFileDownload size="32px" />
          <Text fontSize="2xl" fontWeight="semibold">Download exam questions</Text>
          <Text fontSize="lg" fontWeight="bold">PDF</Text>
        </VStack>
        <Box
          position="absolute"
          top="0"
          left="0"
          right="0"
          bottom="0"
          bg={colorMode === 'light' ? 'gray.100' : 'gray.700'}
          opacity="0.7"
          zIndex="1"
        />
      </Box>
      
      <Box
        as="button"
        position="absolute"
        top="-20px"
        right="-20px"
        transform="rotate(12deg)"
        bgGradient={premiumGradients[colorMode].normal}
        color="white"
        fontWeight="bold"
        fontSize="lg"
        borderRadius="full"
        px={6}
        py={3}
        border="1px solid"
        borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
        boxShadow={colorMode === 'light'
          ? "0 2px 0 0 black"
          : "0 2px 0 0 rgba(255, 255, 255, 0.2)"}
        _hover={{
          bgGradient: premiumGradients[colorMode].hover,
        }}
        _active={{
          boxShadow: "none",
          transform: "rotate(12deg) translateY(2px)",
        }}
        zIndex="2"
        cursor="pointer"
      >
         Go Premium! <Box as={FaChevronRight} display="inline-block" ml={1} />
      </Box>
    </Box>
  );
};

export default DownloadBox;
----
ExamCard.js
import React, { useState, useRef, useEffect } from "react";
import { Box, Text, Progress, Flex, Tooltip, Image, useColorMode, Button } from "@chakra-ui/react";
import { useNavigate } from "react-router-dom";
import { getBadgeUrl } from "./BadgeUrls";

const ExamCard = React.memo(({ title, progress, totalQuestions, view, examId }) => {
  const navigate = useNavigate();
  const { colorMode } = useColorMode();
  const progressPercentage = (progress / totalQuestions) * 100;

  const BadgeImage = ({ size }) => (
    <Image
      src={getBadgeUrl(title)}
      alt="badge"
      width={`${size}px`}
      height={`${size}px`}
      objectFit="contain"
    />
  );

  const [isTruncatedGrid, setIsTruncatedGrid] = useState(false);
  const textRefGrid = useRef(null);

  const [isTruncatedList, setIsTruncatedList] = useState(false);
  const textRefList = useRef(null);

  useEffect(() => {
    if (view === "grid") {
      const textElement = textRefGrid.current;
      if (textElement) {
        const isOverflowing = textElement.scrollHeight > textElement.clientHeight;
        setIsTruncatedGrid(isOverflowing);
      }
    } else {
      const textElement = textRefList.current;
      if (textElement) {
        const isOverflowing = textElement.scrollWidth > textElement.clientWidth;
        setIsTruncatedList(isOverflowing);
      }
    }
  }, [title, view]);

  const handleContinue = () => {
    if (examId) {
      navigate(`/actual-exam/${examId}`);
    } else {
      console.error("Exam ID is undefined");
    }
  };

  const formatTitle = (title) => {
    const parts = title.split('-code-');
    if (parts.length === 2) {
      let [examName, examCode] = parts;
      if (examName.toLowerCase().includes("google")) {
        return examName;
      } else if (examName.toLowerCase().includes("microsoft")) {
        examCode = examCode.split('-').map((part, index) => {
          if (index === 0) {
            return part.toUpperCase();
          }
          if (index === 1 && ['DP', 'MD', 'AI'].includes(examCode.split('-')[0].toUpperCase())) {
            return part.toUpperCase();
          }
          return part;
        }).join('-');
        
        return `${examCode}: ${examName}`;
      } else {
        return `${examCode.toUpperCase()}: ${examName}`;
      }
    }
    return title;
  };

  const formattedTitle = formatTitle(title);

  if (view === "grid") {
    return (
      <Box
        backgroundColor={colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"}
        borderRadius="12px"
        border="1px solid"
        borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
        boxShadow={colorMode === 'light' 
          ? "0 4px 0 0 black"
          : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
        }
        padding={3}
        width={{ base: "100%", sm: "250px", md: "280px", lg: "300px" }}
        height="300px"
        flexShrink={0}
        display="flex"
        flexDirection="column"
      >
        <Tooltip label={formattedTitle} isDisabled={!isTruncatedGrid}>
          <Text
            ref={textRefGrid}
            fontSize={{ base: "14px", md: "16px", lg: "18px" }}
            fontWeight="bold"
            marginBottom={2}
            lineHeight="1.2"
            height="2.4em"
            overflow="hidden"
            textOverflow="ellipsis"
            display="-webkit-box"
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
            sx={{
              WebkitLineClamp: 2,
              WebkitBoxOrient: "vertical",
            }}
          >
            {formattedTitle}
          </Text>
        </Tooltip>
        <Box
          flexGrow={1}
          display="flex"
          justifyContent="center"
          alignItems="center"
          marginBottom={2}
        >
          <BadgeImage size={150} />
        </Box>
        <Progress
          value={progressPercentage}
          colorScheme="blue"
          marginBottom={2}
          height="8px"
          width="100%"
          borderRadius="4px"
          backgroundColor={colorMode === 'light' ? "gray.200" : "gray.600"}
        />
        <Flex justifyContent="space-between" alignItems="center">
          <Text
            fontSize={{ base: "12px", md: "13px", lg: "14px" }}
            color={colorMode === 'light' ? "gray.600" : "gray.400"}
          >
            {progress} / {totalQuestions} questions
          </Text>
          <Button
            onClick={handleContinue}
            height="40px"
            paddingLeft="16px"
            paddingRight="16px"
            backgroundColor={colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"}
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
            fontWeight={700}
            fontSize={{ base: "12px", md: "13px", lg: "14px" }}
            borderRadius="full"
            border="1px solid"
            borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
            boxShadow={colorMode === 'light' 
              ? "0 4px 0 0 black"
              : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
            }
            _hover={{
              backgroundColor: colorMode === 'light' ? "brand.primary.dark" : "brand.primary.light",
              transform: "translateY(2px)",
              boxShadow: colorMode === 'light'
                ? "0 2px 0 0 black"
                : "0 2px 0 0 rgba(255, 255, 255, 0.2)",
            }}
            _active={{
              transform: "translateY(4px)",
              boxShadow: "none",
            }}
            transition="all 0.2s"
          >
            Continue
          </Button>
        </Flex>
      </Box>
    );
  } else {
    return (
      <Flex
        alignItems="center"
        paddingY={2}
        paddingLeft={4}
        borderBottom="1px solid"
        borderColor={colorMode === 'light' ? "gray.200" : "gray.600"}
      >
        <Box width="80px" height="80px" marginRight={4} flexShrink={0}>
          <BadgeImage size={80} />
        </Box>
        <Box flex="1" minWidth="200px">
          <Tooltip label={formattedTitle} isDisabled={!isTruncatedList}>
            <Text
              ref={textRefList}
              fontSize={{ base: "14px", md: "16px", lg: "18px" }}
              fontWeight="bold"
              isTruncated
              color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
            >
              {formattedTitle}
            </Text>
          </Tooltip>
        </Box>
        <Box width="25%" paddingX={2}>
          <Progress
            value={progressPercentage}
            colorScheme="blue"
            height="8px"
            width="100%"
            borderRadius="4px"
            backgroundColor={colorMode === 'light' ? "gray.200" : "gray.600"}
          />
        </Box>
        <Text
          fontSize={{ base: "12px", md: "13px", lg: "14px" }}
          color={colorMode === 'light' ? "gray.600" : "gray.400"}
          width="15%"
          textAlign="right"
        >
          {progress} / {totalQuestions}
        </Text>
        <Button
          onClick={handleContinue}
          height="40px"
          paddingLeft="16px"
          paddingRight="16px"
          marginLeft={2}
          backgroundColor={colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"}
          color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
          fontWeight={700}
          fontSize={{ base: "12px", md: "13px", lg: "14px" }}
          borderRadius="full"
          border="1px solid"
          borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
          boxShadow={colorMode === 'light' 
            ? "0 4px 0 0 black"
            : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
          }
          _hover={{
            backgroundColor: colorMode === 'light' ? "brand.primary.dark" : "brand.primary.light",
            transform: "translateY(2px)",
            boxShadow: colorMode === 'light'
              ? "0 2px 0 0 black"
              : "0 2px 0 0 rgba(255, 255, 255, 0.2)",
          }}
          _active={{
            transform: "translateY(4px)",
            boxShadow: "none",
          }}
          transition="all 0.2s"
        >
          Continue
        </Button>
      </Flex>
    );
  }
});

export default ExamCard;
----
IconBox.js
import React, { useState } from 'react';
import { Box, Flex, useColorMode } from '@chakra-ui/react';
import { PiSealFill, PiSeal, PiStar, PiStarFill } from 'react-icons/pi';

// Generic IconBox component
const IconBox = ({
  icon: Icon,
  size = '48px',
  iconScale = 0.5,
  onClick,
  withBorder = true,
  borderThickness = 3,
  isActive = false
}) => {
  const { colorMode } = useColorMode();
  const iconSize = `${parseInt(size) * iconScale}px`;

  return (
    <Box
      position="relative"
      width={size}
      height={size}
      onClick={onClick}
      cursor="pointer"
      transition="all 0.1s ease"
      transform="scale(1)"
      userSelect="none"
    >
      <Box
        as={PiSealFill}
        size={size}
        color={isActive
          ? (colorMode === 'light' ? 'brand.secondary.light' : 'brand.secondary.dark')
          : (colorMode === 'light' ? 'brand.background.light' : 'brand.surface.dark')
        }
      />
      {withBorder && (
        <Box
          as={PiSeal}
          position="absolute"
          top="0"
          left="0"
          style={{
            width: size,
            height: size,
          }}
          sx={{
            svg: {
              strokeWidth: borderThickness,
              stroke: colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark',
              fill: 'none',
            },
            path: {
              strokeWidth: borderThickness,
              stroke: colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark',
              fill: 'none',
            },
          }}
        />
      )}
      <Flex
        position="absolute"
        top="50%"
        left="50%"
        transform="translate(-50%, -50%)"
        alignItems="center"
        justifyContent="center"
      >
        <Icon
          size={iconSize}
          color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
        />
      </Flex>
    </Box>
  );
};

// Specialized StarIconBox component
const StarIconBox = ({
  size = '48px',
  iconScale = 0.5,
  onClick,
  isStarFilled = false
}) => {
  const [isPressed, setIsPressed] = useState(false);
  const { colorMode } = useColorMode();
  const iconSize = `${parseInt(size) * iconScale}px`;
  const starFillColor = "#FFD700"; // Gold color for star

  return (
    <Box
      position="relative"
      width={size}
      height={size}
      onClick={onClick}
      onMouseDown={() => setIsPressed(true)}
      onMouseUp={() => setIsPressed(false)}
      onMouseLeave={() => setIsPressed(false)}
      cursor="pointer"
      transition="all 0.1s ease"
      transform={isPressed ? 'scale(0.95)' : 'scale(1)'}
      userSelect="none"
    >
      {/* Background seal */}
      <Box
        as={PiSealFill}
        size={size}
        color={colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"}
      />
      
      {/* Border */}
      <Box
        as={PiSeal}
        position="absolute"
        top="0"
        left="0"
        style={{
          width: size,
          height: size,
        }}
        sx={{
          svg: {
            strokeWidth: 3,
            stroke: colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark',
            fill: 'none',
          },
          path: {
            strokeWidth: 3,
            stroke: colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark',
            fill: 'none',
          },
        }}
      />
      
      {/* Star icon */}
      <Flex
        position="absolute"
        top="50%"
        left="50%"
        transform="translate(-50%, -50%)"
        alignItems="center"
        justifyContent="center"
      >
        <Box position="relative" width={iconSize} height={iconSize}>
          {isStarFilled && (
            <Box
              as={PiStarFill}
              size={iconSize}
              color={starFillColor}
              position="absolute"
              top="0"
              left="0"
              zIndex={1}
            />
          )}
          <Box
            as={PiStar}
            size={iconSize}
            color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
            position="absolute"
            top="0"
            left="0"
            zIndex={2}
          />
        </Box>
      </Flex>
    </Box>
  );
};

export { IconBox, StarIconBox };
----
Navbar.js
import React from 'react';
import { Box, Text, Flex, Avatar, HStack, useColorMode, useColorModeValue } from '@chakra-ui/react';
import { RiMoonFill, RiSunFill } from 'react-icons/ri';

const Navbar = ({ activeItem, children }) => {
  const { colorMode, toggleColorMode } = useColorMode();
  
  // Dynamic color values from our theme
  const bgColor = useColorModeValue('brand.background.light', 'brand.background.dark');
  const borderColor = useColorModeValue('brand.border.light', 'brand.border.dark');
  const textColor = useColorModeValue('brand.text.light', 'brand.text.dark');
  const highlightBg = useColorModeValue('brand.secondary.light', 'brand.secondary.dark');
  const toggleBg = useColorModeValue('brand.surface.light', 'brand.surface.dark');
  const toggleIconBg = useColorModeValue('brand.primary.light', 'brand.primary.dark');
  const helloTextColor = useColorModeValue('gray.600', 'gray.400');

  return (
    <Flex 
      justify="space-between" 
      align="center" 
      p={4} 
      pl={10}
      bg={bgColor}
      borderBottom="1px solid" 
      borderColor={borderColor}
      transition="all 0.2s"
    >
      <Flex align="center" overflow="hidden" flex={1} minWidth={0}>
        <Box flexShrink={0} mr={4}>
          <Text
            fontFamily="heading"
            fontWeight={700}
            fontSize="24px"
            lineHeight="29px"
            color={textColor}
            transition="color 0.2s"
          >
            <Box
              as="span"
              bg={highlightBg}
              px="1"
              py="0"
              borderRadius="8px"
            >
              {activeItem}
            </Box>
          </Text>
        </Box>
        <Box overflow="hidden" flex={1} minWidth={0}>
          {children}
        </Box>
      </Flex>

      <HStack spacing={4} flexShrink={0} ml={4}>
        <Flex align="center">
          <Box
            width="52px"
            height="24px"
            bg={toggleBg}
            borderRadius="full"
            display="flex"
            alignItems="center"
            padding="2px"
            cursor="pointer"
            onClick={toggleColorMode}
            border="1px solid"
            borderColor={borderColor}
            position="relative"
            _hover={{
              opacity: 0.8
            }}
            transition="all 0.2s"
          >
            <Box
              width="16px"
              height="16px"
              bg={toggleIconBg}
              borderRadius="full"
              transform={colorMode === 'light' ? "translateX(3px)" : "translateX(27px)"}
              transition="all 0.2s"
              border="1px solid"
              borderColor={borderColor}
              display="flex"
              alignItems="center"
              justifyContent="center"
              color={textColor}
            >
              {colorMode === 'light' ? 
                <RiSunFill size="10px" /> : 
                <RiMoonFill size="10px" />
              }
            </Box>
          </Box>
          <Text
            fontFamily="body"
            fontWeight={500}
            fontSize="16px"
            lineHeight="24px"
            color={textColor}
            ml={2}
            transition="color 0.2s"
          >
            {colorMode === 'light' ? "Light theme" : "Dark theme"}
          </Text>
        </Flex>
        <Flex align="center">
          <Text
            fontFamily="body"
            fontWeight={700}
            fontSize="20px"
            lineHeight="30px"
            color={helloTextColor}
            mr={1}
            transition="color 0.2s"
          >
            Hello,
          </Text>
          <Text
            fontFamily="body"
            fontWeight={700}
            fontSize="20px"
            lineHeight="30px"
            color={textColor}
            mr={2}
            transition="color 0.2s"
          >
            rsduran!
          </Text>
          <Avatar src="https://bit.ly/dan-abramov" size="md" />
        </Flex>
      </HStack>
    </Flex>
  );
};

export default Navbar;
----
OptionsBox.js
import React, { useState } from 'react';
import { Box, Text, Flex, VStack, useColorMode } from '@chakra-ui/react';
import { ChevronDownIcon, ChevronUpIcon } from '@chakra-ui/icons';

const sanitizeOptionText = (text) => {
  return text.replace(/<[^>]*>/g, '')
             .replace(/Most Voted/g, '')
             .trim();
};

const OptionBox = ({ option, isSelected, onClick, isDisabled }) => {
  const { colorMode } = useColorMode();
  
  return (
    <Box
      onClick={isDisabled ? undefined : onClick}
      bg={isSelected 
        ? colorMode === 'light' ? 'brand.primary.light' : 'brand.primary.dark'
        : colorMode === 'light' ? 'brand.background.light' : 'brand.surface.dark'
      }
      borderRadius="10px"
      border="1px solid"
      borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
      padding="16px"
      cursor={isDisabled ? "not-allowed" : "pointer"}
      opacity={isDisabled ? 0.5 : 1}
      transition="all 0.15s ease"
      _hover={!isDisabled && {
        bg: isSelected 
          ? colorMode === 'light' ? 'brand.primary.light' : 'brand.primary.dark'
          : colorMode === 'light' ? 'brand.secondary.light' : 'brand.secondary.dark'
      }}
    >
      <Text 
        fontWeight={700} 
        fontSize="16px" 
        lineHeight="19px" 
        color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
      >
        {sanitizeOptionText(option)}
      </Text>
    </Box>
  );
};

const OptionsBox = ({ options, selectedOptions, onOptionSelect, maxSelections, isUnansweredTab }) => {
  const { colorMode } = useColorMode();
  const [isOpen, setIsOpen] = useState(true);

  const toggleDropdown = () => {
    setIsOpen(!isOpen);
  };

  const handleSelect = (index) => {
    if (selectedOptions.includes(index)) {
      onOptionSelect(selectedOptions.filter(i => i !== index));
    } else if (selectedOptions.length < maxSelections) {
      onOptionSelect([...selectedOptions, index]);
    }
  };

  return (
    <Box
      width="100%"
      bg={colorMode === 'light' ? 'brand.surface.light' : 'brand.surface.dark'}
      borderRadius="20px"
      border="1px solid"
      borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
      boxShadow={colorMode === 'light' 
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"}
      position="relative"
      overflow="hidden"
      marginTop={4}
    >
      <Flex 
        justifyContent="space-between" 
        alignItems="center" 
        padding={6}
        onClick={toggleDropdown} 
        cursor="pointer"
      >
        <Text 
          fontSize="24px" 
          fontWeight="700" 
          color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
        >
          Options (Select {maxSelections})
        </Text>
        {isOpen ? 
          <ChevronUpIcon 
            boxSize={6} 
            color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'} 
          /> : 
          <ChevronDownIcon 
            boxSize={6} 
            color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'} 
          />
        }
      </Flex>
      
      <Box
        height={isOpen ? 'auto' : '0'}
        transition="height 0.2s ease"
        overflow="hidden"
      >
        <VStack spacing={2} align="stretch" paddingX={6} paddingBottom={6}>
          {options.map((option, index) => (
            <OptionBox
              key={index}
              option={option}
              isSelected={selectedOptions.includes(index)}
              onClick={() => handleSelect(index)}
              isDisabled={!selectedOptions.includes(index) && selectedOptions.length >= maxSelections}
            />
          ))}
        </VStack>
        {isUnansweredTab && selectedOptions.length < maxSelections && (
          <Text 
            color={colorMode === 'light' ? 'red.500' : 'red.300'} 
            paddingX={6} 
            paddingBottom={4}
          >
            {maxSelections - selectedOptions.length} more selection{maxSelections - selectedOptions.length !== 1 ? 's' : ''} required
          </Text>
        )}
      </Box>
    </Box>
  );
};

export default OptionsBox;
----
Pagination.js
import React from 'react';
import { Flex, Text, Box, useColorMode } from '@chakra-ui/react';
import { ChevronLeftIcon, ChevronRightIcon } from '@chakra-ui/icons';

const Pagination = ({ currentPage, totalPages, onPageChange }) => {
  const { colorMode } = useColorMode();

  const getPageNumbers = () => {
    const pageNumbers = [];
    if (totalPages <= 7) {
      for (let i = 1; i <= totalPages; i++) {
        pageNumbers.push(i);
      }
    } else {
      if (currentPage <= 4) {
        for (let i = 1; i <= 5; i++) {
          pageNumbers.push(i);
        }
        pageNumbers.push('...');
        pageNumbers.push(totalPages);
      } else if (currentPage >= totalPages - 3) {
        pageNumbers.push(1);
        pageNumbers.push('...');
        for (let i = totalPages - 4; i <= totalPages; i++) {
          pageNumbers.push(i);
        }
      } else {
        pageNumbers.push(1);
        pageNumbers.push('...');
        for (let i = currentPage - 1; i <= currentPage + 1; i++) {
          pageNumbers.push(i);
        }
        pageNumbers.push('...');
        pageNumbers.push(totalPages);
      }
    }
    return pageNumbers;
  };

  const pageNumbers = getPageNumbers();

  return (
    <Flex justifyContent="center" alignItems="center" marginTop={8} marginBottom={4}>
      <Flex
        as="button"
        onClick={() => onPageChange(currentPage - 1)}
        isDisabled={currentPage === 1}
        alignItems="center"
        marginRight={2}
        color={currentPage === 1 
          ? colorMode === 'light' ? "gray.400" : "gray.600"
          : colorMode === 'light' ? "brand.text.light" : "brand.text.dark"
        }
        fontWeight="bold"
        _hover={{ 
          color: currentPage === 1 
            ? colorMode === 'light' ? "gray.400" : "gray.600"
            : colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"
        }}
        _active={{ 
          color: currentPage === 1 
            ? colorMode === 'light' ? "gray.400" : "gray.600"
            : colorMode === 'light' ? "brand.primary.dark" : "brand.primary.light"
        }}
        cursor={currentPage === 1 ? "not-allowed" : "pointer"}
      >
        <ChevronLeftIcon marginRight={1} />
        Previous
      </Flex>
      {pageNumbers.map((number, index) => (
        number === '...' ? (
          <Text 
            key={index} 
            marginX={1}
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
          >
            ...
          </Text>
        ) : (
          <Box
            key={index}
            as="button"
            marginX={1}
            width="40px"
            height="40px"
            display="flex"
            alignItems="center"
            justifyContent="center"
            borderRadius="lg"
            backgroundColor={currentPage === number 
              ? colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"
              : colorMode === 'light' ? "brand.background.light" : "rgba(255, 255, 255, 0.2)"
            }
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
            fontWeight="bold"
            border="1px solid"
            borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
            boxShadow={colorMode === 'light'
              ? "0 2px 0 0 black"
              : "0 2px 0 0 rgba(255, 255, 255, 0.2)"
            }
            onClick={() => onPageChange(number)}
            _hover={{ 
              backgroundColor: currentPage === number 
                ? colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"
                : colorMode === 'light' ? "brand.secondary.light" : "brand.secondary.dark"
            }}
            _active={{ 
              boxShadow: "none", 
              transform: "translateY(2px)" 
            }}
          >
            {number}
          </Box>
        )
      ))}
      <Flex
        as="button"
        onClick={() => onPageChange(currentPage + 1)}
        isDisabled={currentPage === totalPages}
        alignItems="center"
        marginLeft={2}
        color={currentPage === totalPages 
          ? colorMode === 'light' ? "gray.400" : "gray.600"
          : colorMode === 'light' ? "brand.text.light" : "brand.text.dark"
        }
        fontWeight="bold"
        _hover={{ 
          color: currentPage === totalPages 
            ? colorMode === 'light' ? "gray.400" : "gray.600"
            : colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"
        }}
        _active={{ 
          color: currentPage === totalPages 
            ? colorMode === 'light' ? "gray.400" : "gray.600"
            : colorMode === 'light' ? "brand.primary.dark" : "brand.primary.light"
        }}
        cursor={currentPage === totalPages ? "not-allowed" : "pointer"}
      >
        Next
        <ChevronRightIcon marginLeft={1} />
      </Flex>
    </Flex>
  );
};

export default Pagination;
----
ProviderCard.js
import React, { useState } from "react";
import { Box, Text, Flex, Input, Icon, useColorMode } from "@chakra-ui/react";
import { BsBookmarkFill } from "react-icons/bs";
import ExamCard from "./ExamCard";

const ProviderCard = ({ providerName, exams, view, isPopular }) => {
  const { colorMode } = useColorMode();
  const [searchTerm, setSearchTerm] = useState("");
  const [isBookmarked, setIsBookmarked] = useState(false);

  const filteredExams = exams.filter((exam) =>
    exam.title.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const toggleBookmark = () => {
    setIsBookmarked(!isBookmarked);
  };

  const renderExams = () => {
    if (filteredExams.length === 0) {
      return (
        <Box paddingY={4} textAlign="center">
          <Text 
            fontSize="lg" 
            color={colorMode === 'light' ? "gray.600" : "gray.400"}
          >
            No exams or questions available for this provider.
          </Text>
        </Box>
      );
    }

    if (view === "grid") {
      return (
        <Box overflowX="auto" paddingBottom={4}>
          <Flex gap={6}>
            {filteredExams.map((exam, index) => (
              <ExamCard
                key={index}
                title={exam.title}
                progress={exam.progress}
                totalQuestions={exam.totalQuestions}
                view={view}
                examId={exam.id}
              />
            ))}
          </Flex>
        </Box>
      );
    } else {
      return (
        <Box>
          {filteredExams.map((exam, index) => (
            <ExamCard
              key={index}
              title={exam.title}
              progress={exam.progress}
              totalQuestions={exam.totalQuestions}
              view={view}
              examId={exam.id}
            />
          ))}
        </Box>
      );
    }
  };

  return (
    <Box
      backgroundColor={colorMode === 'light' ? "brand.surface.light" : "brand.surface.dark"}
      borderRadius="20px"
      border="1px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      boxShadow={colorMode === 'light' 
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
      }
      padding={6}
      marginBottom={8}
      width="100%"
    >
      <Flex
        justifyContent="space-between"
        alignItems="center"
        marginBottom={6}
        flexWrap="wrap"
        gap={4}
      >
        <Flex alignItems="center" gap={4}>
          <Text
            fontSize={{ base: "24px", md: "26px", lg: "28px" }}
            fontWeight="bold"
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
          >
            {providerName}
          </Text>
          {isPopular && (
            <Box
              paddingX={2}
              paddingY={0}
              borderRadius="full"
              display="inline-block"
              alignSelf="center"
              border="1px solid"
              borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
              bgGradient={colorMode === 'light' 
                ? "linear(to-r, #FFD700, #FFA500)"
                : "linear(to-r, #B8860B, #CD853F)"  // Darker gold gradient for dark mode
              }
            >
              <Text 
                fontSize="14px" 
                fontWeight="500" 
                color={colorMode === 'light' ? "black" : "white"}
              >
                Popular
              </Text>
            </Box>
          )}
        </Flex>
        <Flex alignItems="center" gap={4}>
          <Box
            as="button"
            onClick={toggleBookmark}
            transition="all 0.2s"
            _hover={{ transform: "scale(1.1)" }}
            _active={{ transform: "scale(0.9)" }}
          >
            <Icon
              as={BsBookmarkFill}
              color={isBookmarked 
                ? "#FFD700"  // Keep original gold color for bookmark
                : colorMode === 'light' ? "white" : "gray.600"
              }
              boxSize={6}
              strokeWidth={1}
              stroke={colorMode === 'light' ? "black" : "white"}
              transition="all 0.2s"
            />
          </Box>
          <Input
            placeholder="Search exams..."
            size="md"
            width={{ base: "100%", sm: "200px", md: "250px", lg: "300px" }}
            value={searchTerm}
            onChange={(event) => setSearchTerm(event.target.value)}
            backgroundColor={colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"}
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
            borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
            _placeholder={{
              color: colorMode === 'light' ? "gray.500" : "gray.400"
            }}
          />
        </Flex>
      </Flex>
      {renderExams()}
    </Box>
  );
};

export default ProviderCard;
----
ProviderDropdown.js
import React, { useState, useMemo, useRef } from 'react';
import { Box, Text, Button, useColorMode } from '@chakra-ui/react';
import { ChevronDownIcon, ChevronUpIcon } from '@chakra-ui/icons';
import { FixedSizeList as List } from 'react-window';

const ProviderDropdown = ({ providers, selectedProvider, onSelect }) => {
  const { colorMode } = useColorMode();
  const [isOpen, setIsOpen] = useState(false);
  const textRef = useRef(null);

  const toggleDropdown = () => {
    setIsOpen(!isOpen);
  };

  const handleSelect = (provider) => {
    onSelect(provider);
    setIsOpen(false);
  };

  const sortedProviders = useMemo(() => {
    return ["All Providers", "Popular", "Top Picks", ...providers.sort((a, b) => a.localeCompare(b))];
  }, [providers]);

  return (
    <Box position="relative" width="100%">
      <Button
        onClick={toggleDropdown}
        width="100%"
        backgroundColor={colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"}
        color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
        fontWeight={700}
        fontSize="16px"
        lineHeight="19px"
        borderRadius="10px"
        border="1px solid"
        borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
        boxShadow="none"
        _hover={{
          backgroundColor: colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark",
          boxShadow: colorMode === 'light' ? "0 3px 0 0 black" : "0 3px 0 0 rgba(255, 255, 255, 0.2)"
        }}
        _active={{
          backgroundColor: colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark",
          boxShadow: "none"
        }}
        transition="all 0.2s"
        display="flex"
        justifyContent="space-between"
        alignItems="center"
        paddingLeft={4}
        paddingRight={4}
        paddingTop={3}
        paddingBottom={3}
      >
        <Text ref={textRef} isTruncated>
          {selectedProvider}
        </Text>
        {isOpen ? <ChevronUpIcon /> : <ChevronDownIcon />}
      </Button>
      {isOpen && (
        <Box
          position="absolute"
          top="100%"
          left={0}
          width="100%"
          height="300px"
          backgroundColor={colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"}
          borderRadius="10px"
          border="1px solid"
          borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
          marginTop={2}
          zIndex={1}
          overflow="hidden"
        >
          <List
            height={300}
            itemCount={sortedProviders.length}
            itemSize={40}
            width="100%"
          >
            {({ index, style }) => (
              <Box
                style={style}
                paddingTop={2}
                paddingBottom={2}
                paddingLeft={4}
                paddingRight={4}
                cursor="pointer"
                backgroundColor={
                  sortedProviders[index] === selectedProvider
                    ? colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"
                    : colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"
                }
                _hover={{ 
                  backgroundColor: sortedProviders[index] === selectedProvider 
                    ? colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"
                    : colorMode === 'light' ? "brand.secondary.light" : "brand.secondary.dark"
                }}
                onClick={() => handleSelect(sortedProviders[index])}
                borderBottom={
                  index < sortedProviders.length - 1 
                    ? `1px solid ${colorMode === 'light' ? "#E2E8F0" : "#4A5568"}`
                    : "none"
                }
              >
                <Text 
                  fontWeight={700} 
                  fontSize="16px" 
                  lineHeight="19px" 
                  color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
                  isTruncated
                >
                  {sortedProviders[index]}
                </Text>
              </Box>
            )}
          </List>
        </Box>
      )}
    </Box>
  );
};

export default ProviderDropdown;
----
ProviderExamsCard.js
import React, { useState, useEffect } from "react";
import { useLocation } from "react-router-dom";
import {
  VStack,
  Flex,
  Input,
  Box,
  Container,
  Text,
  Center,
  Spinner,
  useColorMode,
} from "@chakra-ui/react";
import { LuGrid, LuList } from "react-icons/lu";
import { IconBox } from "./IconBox";
import ProviderDropdown from "./ProviderDropdown";
import Pagination from "./Pagination";
import { debounce } from "lodash";
import ProviderCard from "./ProviderCard";

const LoadingSpinner = () => {
  const { colorMode } = useColorMode();
  
  return (
    <Center height="200px">
      <Spinner 
        size="xl" 
        color={colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"} 
        thickness="4px" 
      />
    </Center>
  );
};

const ProviderExamsCard = ({ onExamSelect, view, onViewChange }) => {
  const location = useLocation();
  const { colorMode } = useColorMode();
  const [providers, setProviders] = useState([]);
  const [selectedProvider, setSelectedProvider] = useState("All Providers");
  const [searchTerm, setSearchTerm] = useState("");
  const [isLoading, setIsLoading] = useState(true);
  const [currentPage, setCurrentPage] = useState(1);
  const providersPerPage = 3;

  useEffect(() => {
    if (location.state?.selectedProvider && location.state?.fromProviders) {
      setSelectedProvider(location.state.selectedProvider);
    }
  }, [location]);

  const fetchProviders = async () => {
    setIsLoading(true);
    try {
      const response = await fetch(`http://localhost:5000/api/providers`);
      const data = await response.json();
      setProviders(data.providers);
    } catch (error) {
      console.error('Error fetching providers:', error);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchProviders();
  }, []);

  const allProviders = React.useMemo(() => {
    return ["All Providers", ...providers.map(provider => provider.name)];
  }, [providers]);

  const filteredProviders = React.useMemo(() => {
    let filtered = providers;
    if (selectedProvider !== "All Providers") {
      filtered = filtered.filter(
        (provider) => provider.name === selectedProvider
      );
    }
    if (searchTerm) {
      filtered = filtered
        .map((provider) => ({
          ...provider,
          exams: provider.exams.filter((exam) =>
            exam.title.toLowerCase().includes(searchTerm.toLowerCase())
          ),
        }))
        .filter((provider) => provider.exams.length > 0);
    }
    return filtered.sort((a, b) => {
      if (a.isPopular && !b.isPopular) return -1;
      if (!a.isPopular && b.isPopular) return 1;
      return a.name.localeCompare(b.name);
    });
  }, [providers, selectedProvider, searchTerm]);

  const paginatedProviders = React.useMemo(() => {
    const startIndex = (currentPage - 1) * providersPerPage;
    const endIndex = startIndex + providersPerPage;
    return filteredProviders.slice(startIndex, endIndex);
  }, [filteredProviders, currentPage]);

  const totalPages = Math.ceil(filteredProviders.length / providersPerPage);

  const debouncedSearch = React.useMemo(
    () => debounce((value) => setSearchTerm(value), 300),
    []
  );

  const handleSearch = (event) => {
    debouncedSearch(event.target.value);
    setCurrentPage(1);
  };

  const handlePageChange = (newPage) => {
    setCurrentPage(newPage);
  };

  const handleProviderSelect = (provider) => {
    setSelectedProvider(provider);
    setCurrentPage(1);
  };

  const renderContent = () => {
    if (isLoading) {
      return <LoadingSpinner />;
    }
    if (paginatedProviders.length === 0) {
      return (
        <Text 
          fontSize="xl" 
          textAlign="center" 
          marginY={8}
          color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
        >
          No exams found. Try adjusting your search or selected provider.
        </Text>
      );
    } else {
      return (
        <VStack spacing={6} width="100%">
          {paginatedProviders.map((provider, index) => (
            <ProviderCard
              key={index}
              providerName={provider.name}
              exams={provider.exams}
              view={view}
              isPopular={provider.isPopular}
              onExamSelect={onExamSelect}
            />
          ))}
        </VStack>
      );
    }
  };

  return (
    <Container maxWidth="100%" paddingLeft={4} paddingRight={4}>
      <VStack spacing={8} align="stretch" width="100%">
        <Flex alignItems="center" justifyContent="space-between" gap={4} flexWrap="wrap">
          <Input
            placeholder="Search exams..."
            size="lg"
            width={{ base: "100%", md: "400px" }}
            onChange={handleSearch}
            bg={colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"}
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
            borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
            _placeholder={{
              color: colorMode === 'light' ? "gray.500" : "gray.400"
            }}
          />
          <Flex alignItems="center" gap={4}>
            <Box width="250px">
              <ProviderDropdown
                providers={allProviders}
                selectedProvider={selectedProvider}
                onSelect={handleProviderSelect}
              />
            </Box>
            <Flex gap={2}>
              <IconBox
                icon={LuGrid}
                size="48px"
                iconScale={0.4}
                borderThickness={3}
                backgroundColor={view === "grid" 
                  ? colorMode === 'light' ? "brand.secondary.light" : "brand.secondary.dark"
                  : colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"
                }
                onClick={() => onViewChange("grid")}
                isActive={view === "grid"}
              />
              <IconBox
                icon={LuList}
                size="48px"
                iconScale={0.4}
                borderThickness={3}
                backgroundColor={view === "list"
                  ? colorMode === 'light' ? "brand.secondary.light" : "brand.secondary.dark"
                  : colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"
                }
                onClick={() => onViewChange("list")}
                isActive={view === "list"}
              />
            </Flex>
          </Flex>
        </Flex>
        {renderContent()}
        <Pagination
          currentPage={currentPage}
          totalPages={totalPages}
          onPageChange={handlePageChange}
        />
      </VStack>
    </Container>
  );
};

export default ProviderExamsCard;
----
ProviderInfoCard.js
import React, { useState, useRef, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import {
  Box,
  Text,
  Flex,
  Image,
  Tooltip,
  useColorMode,
  Button,
} from "@chakra-ui/react";

const ProviderInfoCard = ({ provider, view }) => {
  const navigate = useNavigate();
  const { colorMode } = useColorMode();
  const {
    name,
    description,
    image,
    totalExams,
    totalQuestions,
    isPopular,
  } = provider;

  // Hooks for text truncation
  const [isTruncatedGrid, setIsTruncatedGrid] = useState(false);
  const textRefGrid = useRef(null);

  const [isTruncatedList, setIsTruncatedList] = useState(false);
  const textRefList = useRef(null);

  useEffect(() => {
    if (view === "grid") {
      const textElement = textRefGrid.current;
      if (textElement) {
        const isOverflowing =
          textElement.scrollHeight > textElement.clientHeight;
        setIsTruncatedGrid(isOverflowing);
      }
    } else {
      const textElement = textRefList.current;
      if (textElement) {
        const isOverflowing =
          textElement.scrollWidth > textElement.clientWidth;
        setIsTruncatedList(isOverflowing);
      }
    }
  }, [name, view]);

  const handleViewExams = () => {
    navigate('/exams', { 
      state: { 
        selectedProvider: name,
        fromProviders: true
      }
    });
  };

  if (view === "grid") {
    return (
      <Box
        backgroundColor={colorMode === 'light' 
          ? "brand.background.light" 
          : "brand.surface.dark"}
        borderRadius="12px"
        border="1px solid"
        borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
        boxShadow={colorMode === 'light' 
          ? "0 4px 0 0 black"
          : "0 4px 0 0 rgba(255, 255, 255, 0.2)"}
        padding={4}
        width="300px"
        height="400px"
        flexShrink={0}
        display="flex"
        flexDirection="column"
        position="relative"
      >
        {isPopular && (
          <Box
            px={2}
            py={0}
            borderRadius="full"
            display="inline-block"
            alignSelf="center"
            border="1px solid black"
            bgGradient="linear(to-r, #FFD700, #FFA500)"
            position="absolute"
            top={2}
            right={2}
          >
            <Text fontSize="14px" fontWeight="500" color="black">
              Popular
            </Text>
          </Box>
        )}
        <Flex
          flexDirection="column"
          alignItems="center"
          justifyContent="space-between"
          height="100%"
        >
          <Box 
            width="100px" 
            height="100px" 
            display="flex" 
            alignItems="center" 
            justifyContent="center" 
            marginBottom={4}
            backgroundColor={colorMode === 'light' 
              ? "transparent"
              : "rgba(255, 255, 255, 1)"}
            borderRadius="md"
            padding={2}
          >
            <Image
              src={image}
              alt={`${name} logo`}
              maxWidth="100%"
              maxHeight="100%"
              objectFit="contain"
            />
          </Box>
          <Tooltip label={name} isDisabled={!isTruncatedGrid}>
            <Text
              ref={textRefGrid}
              fontSize="18px"
              fontWeight="bold"
              textAlign="center"
              marginBottom={2}
              lineHeight="1.2"
              height="2.4em"
              overflow="hidden"
              textOverflow="ellipsis"
              display="-webkit-box"
              color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
              sx={{
                WebkitLineClamp: 2,
                WebkitBoxOrient: "vertical",
              }}
            >
              {name}
            </Text>
          </Tooltip>
          <Text
            fontSize="16px"
            textAlign="center"
            marginBottom={4}
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
          >
            {description}
          </Text>
          <Flex flexDirection="column" width="100%" alignItems="flex-start" marginBottom={4}>
            <Text 
              fontSize="14px" 
              color={colorMode === 'light' ? "gray.600" : "gray.400"}
            >
              Total Exams: {totalExams}
            </Text>
            <Text 
              fontSize="14px" 
              color={colorMode === 'light' ? "gray.600" : "gray.400"}
            >
              Total Questions: {totalQuestions}
            </Text>
          </Flex>
          <Button
            onClick={handleViewExams}
            height="40px"
            paddingLeft="16px"
            paddingRight="16px"
            backgroundColor={colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"}
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
            fontWeight={700}
            fontSize="14px"
            borderRadius="full"
            border="1px solid"
            borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
            boxShadow={colorMode === 'light' 
              ? "0 4px 0 0 black"
              : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
            }
            _hover={{
              backgroundColor: colorMode === 'light' ? "brand.primary.dark" : "brand.primary.light",
              transform: "translateY(2px)",
              boxShadow: colorMode === 'light'
                ? "0 2px 0 0 black"
                : "0 2px 0 0 rgba(255, 255, 255, 0.2)",
            }}
            _active={{
              transform: "translateY(4px)",
              boxShadow: "none",
            }}
            transition="all 0.2s"
            width="100%"
          >
            View Exams
          </Button>
        </Flex>
      </Box>
    );
  } else {
    return (
      <Flex
        alignItems="center"
        paddingY={4}
        paddingX={4}
        borderBottom="1px solid"
        borderColor={colorMode === 'light' ? "gray.200" : "gray.600"}
        backgroundColor={colorMode === 'light' 
          ? "brand.background.light" 
          : "brand.surface.dark"}
      >
        <Box 
          width="80px" 
          height="80px" 
          display="flex" 
          alignItems="center" 
          justifyContent="center" 
          marginRight={4}
          backgroundColor={colorMode === 'light' 
            ? "transparent"
            : "rgba(255, 255, 255, 1)"}
          borderRadius="md"
          padding={2}
        >
          <Image
            src={image}
            alt={`${name} logo`}
            maxWidth="100%"
            maxHeight="100%"
            objectFit="contain"
          />
        </Box>
        <Box flex="1">
          <Tooltip label={name} isDisabled={!isTruncatedList}>
            <Text
              ref={textRefList}
              fontSize="18px"
              fontWeight="bold"
              isTruncated
              color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
            >
              {name}
            </Text>
          </Tooltip>
          <Text 
            fontSize="16px" 
            color={colorMode === 'light' ? "gray.600" : "gray.400"}
          >
            {description}
          </Text>
          <Text 
            fontSize="14px" 
            color={colorMode === 'light' ? "gray.600" : "gray.400"}
          >
            Total Exams: {totalExams}
          </Text>
          <Text 
            fontSize="14px" 
            color={colorMode === 'light' ? "gray.600" : "gray.400"}
          >
            Total Questions: {totalQuestions}
          </Text>
        </Box>
        <Flex alignItems="center">
          {isPopular && (
            <Box
              px={2}
              py={0}
              borderRadius="full"
              display="inline-block"
              border="1px solid black"
              bgGradient="linear(to-r, #FFD700, #FFA500)"
              marginRight={2}
            >
              <Text fontSize="14px" fontWeight="500" color="black">
                Popular
              </Text>
            </Box>
          )}
          <Box
            as="button"
            paddingX={4}
            paddingY={2}
            borderRadius="full"
            backgroundColor={colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"}
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
            fontWeight="bold"
            fontSize="14px"
            border="1px solid"
            borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
            boxShadow={colorMode === 'light' 
              ? "0 2px 0 0 black"
              : "0 2px 0 0 rgba(255, 255, 255, 0.2)"}
            transition="all 0.2s ease-in-out"
            _hover={{ 
              backgroundColor: colorMode === 'light' 
                ? "brand.primary.dark" 
                : "brand.primary.light",
              transform: "translateY(-2px)",
              boxShadow: colorMode === 'light' 
                ? "0 4px 0 0 black"
                : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
            }}
            _active={{ 
              boxShadow: "none", 
              transform: "translateY(2px)",
              backgroundColor: colorMode === 'light' 
                ? "brand.primary.dark" 
                : "brand.primary.light"
            }}
            onClick={handleViewExams}
          >
            View Exams
          </Box>
        </Flex>
      </Flex>
    );
  }
};

export default ProviderInfoCard;
----
ProvidersPage.js
import React, { useState, useEffect, useMemo } from 'react';
import {
  VStack, 
  Flex,
  Input,
  Box,
  Container,
  Center,
  Spinner,
  useColorMode,
} from "@chakra-ui/react";
import { LuGrid, LuList } from "react-icons/lu";
import { IconBox } from "./IconBox";
import CategoriesDropdown from "./CategoriesDropdown";
import Pagination from "./Pagination";
import CategoryCard from "./CategoryCard";
import { debounce } from "lodash";

const LoadingSpinner = () => {
  const { colorMode } = useColorMode();
  
  return (
    <Center height="200px">
      <Spinner 
        size="xl" 
        color={colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"} 
        thickness="4px" 
      />
    </Center>
  );
};

const ProvidersPage = () => {
  const { colorMode } = useColorMode();
  const [categories, setCategories] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [selectedCategory, setSelectedCategory] = useState("All Categories");
  const [view, setView] = useState("grid");
  const [searchTerm, setSearchTerm] = useState("");
  const [currentPage, setCurrentPage] = useState(1);
  const [error, setError] = useState(null);
  const categoriesPerPage = 2;

  const categoryNames = useMemo(() => 
    ["All Categories", ...categories.map(category => category.name)],
    [categories]
  );

  useEffect(() => {
    const fetchProviders = async () => {
      try {
        const response = await fetch('http://localhost:5000/api/provider-statistics');
        if (!response.ok) {
          throw new Error('Failed to fetch provider statistics');
        }
        const data = await response.json();
        setCategories(data.categories);
      } catch (err) {
        console.error('Error fetching providers:', err);
        setError(err.message);
      } finally {
        setIsLoading(false);
      }
    };

    fetchProviders();
  }, []);

  const filteredCategories = useMemo(() => {
    let filtered = categories;
    if (selectedCategory !== "All Categories") {
      filtered = filtered.filter(category => category.name === selectedCategory);
    }
    if (searchTerm) {
      filtered = filtered.map(category => ({
        ...category,
        providers: category.providers.filter(provider =>
          provider.name.toLowerCase().includes(searchTerm.toLowerCase())
        )
      })).filter(category => category.providers.length > 0);
    }
    return filtered;
  }, [categories, selectedCategory, searchTerm]);

  const paginatedCategories = useMemo(() => {
    const startIndex = (currentPage - 1) * categoriesPerPage;
    const endIndex = startIndex + categoriesPerPage;
    return filteredCategories.slice(startIndex, endIndex);
  }, [filteredCategories, currentPage]);

  const totalPages = Math.ceil(filteredCategories.length / categoriesPerPage);

  const debouncedSearch = useMemo(
    () => debounce((value) => setSearchTerm(value), 300),
    []
  );

  const renderContent = () => {
    if (isLoading) {
      return <LoadingSpinner />;
    }

    if (error) {
      return (
        <Center>
          <Box 
            fontSize="xl" 
            color={colorMode === 'light' ? "red.500" : "red.300"}
          >
            Error: {error}
          </Box>
        </Center>
      );
    }

    if (paginatedCategories.length === 0) {
      return (
        <Center>
          <Box 
            fontSize="xl" 
            textAlign="center" 
            marginY={8}
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
          >
            No providers found. Try adjusting your search or selected category.
          </Box>
        </Center>
      );
    }

    return (
      <VStack spacing={6} width="100%">
        {paginatedCategories.map((category, index) => (
          <CategoryCard
            key={index}
            categoryName={category.name}
            providers={category.providers}
            view={view}
          />
        ))}
      </VStack>
    );
  };

  return (
    <Container maxWidth="100%" paddingLeft={4} paddingRight={4}>
      <VStack spacing={8} align="stretch" width="100%">
        <Flex
          alignItems="center"
          justifyContent="space-between"
          gap={4}
          flexWrap="wrap"
        >
          <Input
            placeholder="Search providers..."
            size="lg"
            width={{ base: "100%", md: "400px" }}
            onChange={(e) => debouncedSearch(e.target.value)}
            backgroundColor={colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"}
            color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
            borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
            _placeholder={{
              color: colorMode === 'light' ? "gray.500" : "gray.400"
            }}
          />
          <Flex alignItems="center" gap={4}>
            <Box width="250px">
              <CategoriesDropdown
                categories={categoryNames}
                selectedCategory={selectedCategory}
                onSelect={setSelectedCategory}
              />
            </Box>
            <Flex gap={2}>
              <IconBox
                icon={LuGrid}
                size="48px"
                iconScale={0.4}
                borderThickness={3}
                backgroundColor={view === "grid" 
                  ? colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"
                  : colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"
                }
                onClick={() => setView("grid")}
                isActive={view === "grid"}
              />
              <IconBox
                icon={LuList}
                size="48px"
                iconScale={0.4}
                borderThickness={3}
                backgroundColor={view === "list" 
                  ? colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"
                  : colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"
                }
                onClick={() => setView("list")}
                isActive={view === "list"}
              />
            </Flex>
          </Flex>
        </Flex>
        
        {renderContent()}

        <Pagination
          currentPage={currentPage}
          totalPages={totalPages}
          onPageChange={setCurrentPage}
        />
      </VStack>
    </Container>
  );
};

export default ProvidersPage;
----
QuestionBox.js
import React from 'react';
import { Box, Text, Flex, useColorMode } from '@chakra-ui/react';
import { StarIconBox } from './IconBox';
import { transformImageUrl } from '../utils';

const QuestionBox = ({ 
  questionNumber, 
  totalQuestionsInTopic, 
  questionData, 
  isStarFilled, 
  toggleStar, 
  currentTopic 
}) => {
  const { colorMode } = useColorMode();

  if (!questionData) {
    return (
      <Box
        width="100%"
        bg={colorMode === 'light' ? 'brand.surface.light' : 'brand.surface.dark'}
        borderRadius="20px"
        border="1px solid"
        borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
        boxShadow={colorMode === 'light' 
          ? "0 4px 0 0 black"
          : "0 4px 0 0 rgba(255, 255, 255, 0.2)"}
        position="relative"
        overflow="hidden"
        padding={6}
      >
        <Text 
          fontSize="20px" 
          fontWeight="500"
          color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
        >
          No question data available.
        </Text>
      </Box>
    );
  }

  const transformedBody = questionData.body.replace(
    /<img\s+src="([^"]+)"/g,
    (match, p1) => `<img src="${transformImageUrl(p1)}"`
  );

  return (
    <Box
      width="100%"
      bg={colorMode === 'light' ? 'brand.surface.light' : 'brand.surface.dark'}
      borderRadius="20px"
      border="1px solid"
      borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
      boxShadow={colorMode === 'light' 
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"}
      position="relative"
      overflow="hidden"
      padding={6}
    >
      <Flex justifyContent="space-between" alignItems="center" marginBottom={4}>
        <Box
          bg={colorMode === 'light' ? 'brand.secondary.light' : 'brand.secondary.dark'}
          paddingX={1}
          paddingY={0}
          borderRadius="8px"
        >
          <Text 
            fontSize="24px" 
            fontWeight="700"
            color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
          >
            T{currentTopic} Q{questionNumber} of {totalQuestionsInTopic}
          </Text>
        </Box>
        <StarIconBox
          size="48px"
          iconScale={0.5}
          onClick={toggleStar}
          isStarFilled={isStarFilled}
        />
      </Flex>
      <Box>
        <Text 
          fontSize="20px" 
          fontWeight="500"
          color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
          dangerouslySetInnerHTML={{ __html: transformedBody || "No question text available." }} 
        />
      </Box>
    </Box>
  );
};

export default QuestionBox;
----
QuestionListDropdown.js
import React from 'react';
import { Box, Text, useColorMode } from '@chakra-ui/react';
import { FixedSizeList as List } from 'react-window';

const QuestionListDropdown = React.memo(({ questions, currentQuestion, onSelect }) => {
  const { colorMode } = useColorMode();
  const itemSize = 32; // Height of each item in pixels
  const listHeight = Math.min(questions.length * itemSize, 300); // Max height of 300px

  const Row = ({ index, style }) => {
    const question = questions[index];
    const isSelected = question === currentQuestion;

    return (
      <Box
        style={style}
        paddingTop={2}
        paddingBottom={2}
        paddingLeft={4}
        paddingRight={4}
        cursor="pointer"
        backgroundColor={isSelected 
          ? colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"
          : colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"
        }
        _hover={{
          backgroundColor: isSelected 
            ? colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"
            : colorMode === 'light' ? "brand.secondary.light" : "brand.secondary.dark"
        }}
        onClick={() => onSelect(question)}
        transition="background-color 0.2s"
      >
        <Text 
          fontWeight={700} 
          fontSize="14px" 
          lineHeight="16px" 
          color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
        >
          {question}
        </Text>
      </Box>
    );
  };

  return (
    <Box
      position="absolute"
      top="calc(100% + 8px)"
      left="50%"
      transform="translateX(-50%)"
      width="120px"
      height={listHeight}
      backgroundColor={colorMode === 'light' 
        ? "brand.background.light" 
        : "brand.surface.dark"
      }
      borderRadius="10px"
      border="1px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      zIndex={1000}
      overflow="hidden"
      boxShadow={colorMode === 'light'
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
      }
    >
      <List
        height={listHeight}
        itemCount={questions.length}
        itemSize={itemSize}
        width="100%"
        style={{
          scrollbarWidth: 'thin',
          scrollbarColor: colorMode === 'light' 
            ? '#888 #f5f5f5'
            : '#666 #2d2d2d'
        }}
      >
        {Row}
      </List>
    </Box>
  );
});

export default QuestionListDropdown;
----
QuestionPanel.js
import React, { useState, useEffect, useCallback } from "react";
import { Box, VStack, Text, useColorMode } from "@chakra-ui/react";
import SearchBar from "./SearchBar";
import TabList from "./TabList";
import QuestionBox from "./QuestionBox";
import OptionsBox from "./OptionsBox";
import AnswerBox from "./AnswerBox";

const QuestionPanel = ({
  width = "100%",
  onSearch,
  onShuffle,
  onReset,
  onSubmit,
  tabs,
  onTabChange,
  questionNumber,
  totalQuestions,
  questionData,
  isStarFilled,
  toggleStar,
  onNavigateLeft,
  onNavigateRight,
  currentTopic,
  currentQuestion,
  onQuestionSelect,
  favoriteQuestions,
  onOptionSelect,
  selectedOptions,
  userAnswers,
  unansweredQuestions,
  setUnansweredQuestions,
  incorrectQuestions,
}) => {
  const { colorMode } = useColorMode();

  // State management with default values
  const [currentTab, setCurrentTab] = useState("ALL QUESTIONS");
  const [tabIndices, setTabIndices] = useState({
    "ALL QUESTIONS": questionNumber - 1,
    FAVORITES: 0,
    ANSWERED: 0,
    UNANSWERED: 0,
    INCORRECT: 0,
  });
  const [answeredQuestions, setAnsweredQuestions] = useState([]);
  const [removingQuestion, setRemovingQuestion] = useState(null);
  const [isNavigationDisabled, setIsNavigationDisabled] = useState(false);
  const [displayedQuestionInfo, setDisplayedQuestionInfo] = useState({
    current: questionNumber,
    total: totalQuestions,
  });
  const [pendingUpdate, setPendingUpdate] = useState(null);
  const [lastNavigationAction, setLastNavigationAction] = useState(null);
  const [navigationLock, setNavigationLock] = useState(false);

  // Enhanced debug logger
  const logDebug = (action, details) => {
    console.log(`[QuestionPanel ${action}]`, {
      timestamp: new Date().toISOString(),
      currentTab,
      currentTopic,
      questionNumber,
      navigationState: {
        isDisabled: isNavigationDisabled,
        isLocked: navigationLock,
        lastAction: lastNavigationAction,
      },
      ...details,
    });
  };

  // Utility function to get required selections for a question
  const getRequiredSelections = useCallback((answer) => {
    if (!answer) return 1;
    if (typeof answer === "string") return answer.length;
    if (Array.isArray(answer)) return answer.length;
    return 1;
  }, []);

// Handle question removal from lists
const handleQuestionRemoval = useCallback(
  (questionId) => {
    logDebug("Question Removal", { questionId });
    
    setNavigationLock(true);
    setUnansweredQuestions((prev) => prev.filter((q) => q !== questionId));
    setRemovingQuestion(null);
    setIsNavigationDisabled(false);

    if (currentTab === "UNANSWERED") {
      const currentIndex = unansweredQuestions.findIndex(
        (q) => q === questionId
      );
      let nextQuestion;

      if (currentIndex === unansweredQuestions.length - 1) {
        nextQuestion = unansweredQuestions[currentIndex - 1];
      } else {
        nextQuestion = unansweredQuestions[currentIndex + 1];
      }

      if (nextQuestion) {
        const [topic, question] = nextQuestion.split(" ");
        onQuestionSelect(`${topic} ${question}`);
      }
    }

    setDisplayedQuestionInfo((prevInfo) => ({
      current: Math.min(prevInfo.current, prevInfo.total - 1),
      total: prevInfo.total - 1,
    }));

    // Release navigation lock after a short delay
    setTimeout(() => setNavigationLock(false), 100);
  },
  [currentTab, unansweredQuestions, onQuestionSelect, setUnansweredQuestions]
);

// Handle navigation
const handleNavigate = useCallback(
  (direction) => {
    if (isNavigationDisabled || navigationLock) {
      logDebug("Navigation Blocked", { 
        reason: isNavigationDisabled ? "Navigation disabled" : "Navigation locked",
        navigationLock,
        isNavigationDisabled
      });
      return;
    }

    // Set temporary navigation lock
    setNavigationLock(true);
    setIsNavigationDisabled(true);

    const currentQuestionId = `T${currentTopic} Q${questionNumber}`;
    
    logDebug("Navigation Attempt", {
      direction,
      currentQuestionId,
      currentTab,
      tabIndices: { ...tabIndices }
    });

    switch (currentTab) {
      case "ALL QUESTIONS": {
        if (direction === 1 && questionNumber < totalQuestions) {
          const nextQuestionId = `T${currentTopic} Q${questionNumber + 1}`;
          logDebug("Navigation Right", { from: questionNumber, to: questionNumber + 1 });
          onQuestionSelect(nextQuestionId);
        } else if (direction === -1 && questionNumber > 1) {
          const prevQuestionId = `T${currentTopic} Q${questionNumber - 1}`;
          logDebug("Navigation Left", { from: questionNumber, to: questionNumber - 1 });
          onQuestionSelect(prevQuestionId);
        }
        break;
      }

      case "FAVORITES": {
        const currentIndex = favoriteQuestions.findIndex(
          item => `T${item.topic_number} Q${item.question_index + 1}` === currentQuestionId
        );
        const nextIndex = (currentIndex !== -1 ? currentIndex : tabIndices["FAVORITES"]) + direction;
        
        if (nextIndex >= 0 && nextIndex < favoriteQuestions.length) {
          const favorite = favoriteQuestions[nextIndex];
          const targetQuestion = `T${favorite.topic_number} Q${favorite.question_index + 1}`;
          setTabIndices(prev => ({ ...prev, FAVORITES: nextIndex }));
          onQuestionSelect(targetQuestion);
          logDebug("Navigation Success", { targetQuestion, tab: "FAVORITES" });
        }
        break;
      }

      case "ANSWERED": {
        const answeredIndex = answeredQuestions.indexOf(currentQuestionId);
        const currentIndex = answeredIndex !== -1 ? answeredIndex : tabIndices["ANSWERED"];
        const nextIndex = currentIndex + direction;
        
        if (nextIndex >= 0 && nextIndex < answeredQuestions.length) {
          const targetQuestion = answeredQuestions[nextIndex];
          setTabIndices(prev => ({ ...prev, ANSWERED: nextIndex }));
          
          // Store the target question for delayed navigation
          const [topic, question] = targetQuestion.split(" ");
          const questionNumber = parseInt(question.slice(1));
          
          // Use setTimeout to ensure state updates complete before navigation
          setTimeout(() => {
            onQuestionSelect(`${topic} Q${questionNumber}`);
            setNavigationLock(false);
            setIsNavigationDisabled(false);
          }, 50);
          
          return; // Exit early to prevent immediate lock release
        }
        break;
      }

      case "UNANSWERED": {
        const currentIndex = unansweredQuestions.indexOf(currentQuestionId);
        const nextIndex = (currentIndex !== -1 ? currentIndex : tabIndices["UNANSWERED"]) + direction;
        
        if (nextIndex >= 0 && nextIndex < unansweredQuestions.length) {
          const targetQuestion = unansweredQuestions[nextIndex];
          setTabIndices(prev => ({ ...prev, UNANSWERED: nextIndex }));
          onQuestionSelect(targetQuestion);
          logDebug("Navigation Success", { targetQuestion, tab: "UNANSWERED" });
        }
        break;
      }

      case "INCORRECT": {
        const currentIndex = incorrectQuestions.indexOf(currentQuestionId);
        const nextIndex = (currentIndex !== -1 ? currentIndex : tabIndices["INCORRECT"]) + direction;
        
        if (nextIndex >= 0 && nextIndex < incorrectQuestions.length) {
          const targetQuestion = incorrectQuestions[nextIndex];
          setTabIndices(prev => ({ ...prev, INCORRECT: nextIndex }));
          onQuestionSelect(targetQuestion);
          logDebug("Navigation Success", { targetQuestion, tab: "INCORRECT" });
        }
        break;
      }
    }

    // Release navigation locks after a short delay
    setTimeout(() => {
      setNavigationLock(false);
      setIsNavigationDisabled(false);
      setLastNavigationAction(direction === 1 ? "right" : "left");
    }, 100);
  },
  [
    isNavigationDisabled,
    navigationLock,
    currentTab,
    currentTopic,
    questionNumber,
    totalQuestions,
    tabIndices,
    favoriteQuestions,
    answeredQuestions,
    unansweredQuestions,
    incorrectQuestions,
    onQuestionSelect
  ]
);

// Handle tab changes
const handleTabChange = useCallback(
  (tab) => {
    logDebug("Tab Change", { newTab: tab });
    
    if (navigationLock || isNavigationDisabled) {
      logDebug("Tab Change Blocked", { reason: "Navigation in progress" });
      return;
    }
    
    const currentState = {
      tab: currentTab,
      questionId: `T${currentTopic} Q${questionNumber}`
    };
    
    setCurrentTab(tab);
    setNavigationLock(true);
    setIsNavigationDisabled(true);

    // Store the current position before switching tabs
    const lastPosition = {
      questionId: `T${currentTopic} Q${questionNumber}`,
      index: questionNumber - 1
    };

    // Handle question selection based on tab
    switch(tab) {
      case "ALL QUESTIONS":
        // Use the last known position in ALL QUESTIONS tab
        onQuestionSelect(`T${currentTopic} Q${tabIndices["ALL QUESTIONS"] + 1}`);
        break;
      
      case "FAVORITES":
        if (favoriteQuestions.length > 0) {
          const favorite = favoriteQuestions[tabIndices["FAVORITES"]];
          onQuestionSelect(`T${favorite.topic_number} Q${favorite.question_index + 1}`);
        }
        break;
      
      case "ANSWERED":
        if (answeredQuestions.length > 0) {
          onQuestionSelect(answeredQuestions[Math.min(tabIndices["ANSWERED"], answeredQuestions.length - 1)]);
        }
        break;
      
      case "UNANSWERED":
        if (unansweredQuestions.length > 0) {
          onQuestionSelect(unansweredQuestions[tabIndices["UNANSWERED"]]);
        }
        break;
      
      case "INCORRECT":
        if (incorrectQuestions.length > 0) {
          onQuestionSelect(incorrectQuestions[tabIndices["INCORRECT"]]);
        }
        break;
    }
    
    onTabChange(tab);
    
    // Store the last position of the previous tab before switching
    if (currentTab === "ALL QUESTIONS") {
      setTabIndices(prev => ({
        ...prev,
        "ALL QUESTIONS": questionNumber - 1
      }));
    }
    
    logDebug("Tab Change Complete", { 
      previousState: currentState,
      newTab: tab,
      currentIndices: tabIndices 
    });

    setTimeout(() => {
      setNavigationLock(false);
      setIsNavigationDisabled(false);
    }, 100);
  },
  [
    currentTopic,
    questionNumber,
    tabIndices,
    favoriteQuestions,
    answeredQuestions,
    unansweredQuestions,
    incorrectQuestions,
    onQuestionSelect,
    onTabChange,
    navigationLock,
    isNavigationDisabled,
    currentTab
  ]
);

// Handle question selection
const handleQuestionSelect = useCallback(
  (selectedQuestion) => {
    logDebug("Question Select", { selectedQuestion });

    if (navigationLock || isNavigationDisabled) {
      logDebug("Question Select Blocked", { reason: "Navigation in progress" });
      return;
    }

    setNavigationLock(true);
    
    const [topicPart, questionPart] = selectedQuestion.split(" ");
    const questionIndex = parseInt(questionPart.slice(1)) - 1;

    // Update indices based on the current tab
    if (currentTab === "ALL QUESTIONS") {
      setTabIndices(prev => ({
        ...prev,
        "ALL QUESTIONS": questionIndex
      }));
    } else {
      const currentArray = (() => {
        switch (currentTab) {
          case "FAVORITES":
            return favoriteQuestions;
          case "ANSWERED":
            return answeredQuestions;
          case "UNANSWERED":
            return unansweredQuestions;
          case "INCORRECT":
            return incorrectQuestions;
          default:
            return null;
        }
      })();

      if (currentArray) {
        const arrayIndex = currentArray.indexOf(selectedQuestion);
        if (arrayIndex !== -1) {
          setTabIndices(prev => ({
            ...prev,
            [currentTab]: arrayIndex
          }));
        }
      }
    }

    onQuestionSelect(selectedQuestion);
    
    setTimeout(() => setNavigationLock(false), 100);
  },
  [
    currentTab,
    navigationLock,
    isNavigationDisabled,
    favoriteQuestions,
    answeredQuestions,
    unansweredQuestions,
    incorrectQuestions,
    onQuestionSelect,
  ]
);

// Update tab indices when question number changes
useEffect(() => {
  if (!navigationLock) {
    setTabIndices(prevIndices => ({
      ...prevIndices,
      "ALL QUESTIONS": questionNumber - 1,
    }));
  }
}, [questionNumber, navigationLock]);

// Track answered questions
useEffect(() => {
  if (navigationLock || isNavigationDisabled || currentTab !== "ANSWERED") return;

  const currentQuestionId = `T${currentTopic} Q${questionNumber}`;
  const requiredSelections = getRequiredSelections(questionData.answer);
  const isAnswered = selectedOptions.length === requiredSelections;

  logDebug("Answer Status Check", {
    currentQuestionId,
    requiredSelections,
    isAnswered,
    selectedOptions
  });

  if (isAnswered) {
    setAnsweredQuestions(prev => {
      // Only update if the question isn't already in the list
      if (!prev.includes(currentQuestionId)) {
        const updatedAnswered = [
          ...prev.filter((q) => q !== currentQuestionId),
          currentQuestionId,
        ];
        logDebug("Updated Answered Questions", { updatedAnswered });
        return updatedAnswered;
      }
      return prev;
    });
  }
}, [
  currentTopic,
  questionNumber,
  questionData,
  selectedOptions,
  getRequiredSelections,
  currentTab,
  navigationLock,
  isNavigationDisabled
]);

// Handle pending updates
useEffect(() => {
  if (pendingUpdate) {
    const timer = setTimeout(() => {
      handleQuestionRemoval(pendingUpdate.questionId);
      setPendingUpdate(null);
    }, pendingUpdate.delay);
    return () => clearTimeout(timer);
  }
}, [pendingUpdate, handleQuestionRemoval]);

// Handle incorrect questions tab
useEffect(() => {
  if (navigationLock || isNavigationDisabled) return;

  const currentQuestionId = `T${currentTopic} Q${questionNumber}`;
  const requiredSelections = getRequiredSelections(questionData.answer);
  const hasUserAnswers = userAnswers[currentQuestionId] && 
                        userAnswers[currentQuestionId].length === requiredSelections;

  if (hasUserAnswers && !answeredQuestions.includes(currentQuestionId)) {
    setAnsweredQuestions(prev => [...prev, currentQuestionId]);
  } else if (!hasUserAnswers && answeredQuestions.includes(currentQuestionId)) {
    setAnsweredQuestions(prev => prev.filter(q => q !== currentQuestionId));
  }
}, [
  currentTopic,
  questionNumber,
  questionData,
  userAnswers,
  getRequiredSelections,
  navigationLock,
  isNavigationDisabled,
  answeredQuestions
]);

// Cleanup effect for navigation state
useEffect(() => {
  return () => {
    setNavigationLock(false);
    setIsNavigationDisabled(false);
    setRemovingQuestion(null);
    setPendingUpdate(null);
  };
}, []);

// Update displayed question info
useEffect(() => {
  if (pendingUpdate || navigationLock) return;

  const getCurrentIndex = (array, identifier) => {
    if (currentTab === "FAVORITES") {
      return array.findIndex(
        item => `T${item.topic_number} Q${item.question_index + 1}` === identifier
      );
    }
    return array.indexOf(identifier);
  };

  const currentQuestionId = `T${currentTopic} Q${questionNumber}`;
  const newQuestionInfo = (() => {
    switch (currentTab) {
      case "FAVORITES":
        return {
          current: getCurrentIndex(favoriteQuestions, currentQuestionId) + 1 || tabIndices["FAVORITES"] + 1,
          total: favoriteQuestions.length,
        };
      case "ANSWERED":
        return {
          current: getCurrentIndex(answeredQuestions, currentQuestionId) + 1 || tabIndices["ANSWERED"] + 1,
          total: answeredQuestions.length,
        };
      case "UNANSWERED":
        return {
          current: getCurrentIndex(unansweredQuestions, currentQuestionId) + 1 || tabIndices["UNANSWERED"] + 1,
          total: unansweredQuestions.length,
        };
      case "INCORRECT":
        return {
          current: getCurrentIndex(incorrectQuestions, currentQuestionId) + 1 || tabIndices["INCORRECT"] + 1,
          total: incorrectQuestions.length,
        };
      default:
        return {
          current: questionNumber,
          total: totalQuestions,
        };
    }
  })();

  setDisplayedQuestionInfo(newQuestionInfo);
}, [
  questionNumber,
  totalQuestions,
  currentTab,
  tabIndices,
  favoriteQuestions,
  answeredQuestions,
  unansweredQuestions,
  incorrectQuestions,
  currentTopic,
  pendingUpdate,
  navigationLock
]);

// Render questions based on current tab
const renderQuestions = () => {
  if (currentTab === "ANSWERED" && answeredQuestions.length === 0) {
    return (
      <Text color={colorMode === "light" ? "brand.text.light" : "brand.text.dark"}>
        There are no answered questions yet.
      </Text>
    );
  }

  if (currentTab === "UNANSWERED") {
    if (unansweredQuestions.length === 0) {
      return (
        <Text color={colorMode === "light" ? "brand.text.light" : "brand.text.dark"}>
          There are no unanswered questions.
        </Text>
      );
    }

    const currentQuestionId = `T${currentTopic} Q${questionNumber}`;
    if (!unansweredQuestions.includes(currentQuestionId) && !removingQuestion) {
      const nextQuestion = unansweredQuestions[0];
      const [topic, question] = nextQuestion.split(" ");
      onQuestionSelect(`${topic} ${question}`);
      return null;
    }
  }

  if (currentTab === "FAVORITES" && favoriteQuestions.length === 0) {
    return (
      <Text color={colorMode === "light" ? "brand.text.light" : "brand.text.dark"}>
        There are no favorited questions.
      </Text>
    );
  }

  if (currentTab === "INCORRECT") {
    if (incorrectQuestions.length === 0) {
      return (
        <Text color={colorMode === "light" ? "brand.text.light" : "brand.text.dark"}>
          There are no incorrect questions. Great job!
        </Text>
      );
    }

    const currentQuestionId = `T${currentTopic} Q${questionNumber}`;
    if (!incorrectQuestions.includes(currentQuestionId)) {
      return (
        <Text color={colorMode === "light" ? "brand.text.light" : "brand.text.dark"}>
          Loading next incorrect question...
        </Text>
      );
    }
  }

  return (
    <VStack spacing={4} align="stretch">
      <QuestionBox
        questionNumber={displayedQuestionInfo.current}
        totalQuestionsInTopic={displayedQuestionInfo.total}
        questionData={questionData}
        isStarFilled={isStarFilled}
        toggleStar={toggleStar}
        currentTopic={currentTopic}
      />
      <OptionsBox
        options={questionData.options || []}
        selectedOptions={selectedOptions}
        onOptionSelect={onOptionSelect}
        maxSelections={getRequiredSelections(questionData.answer)}
        isUnansweredTab={currentTab === "UNANSWERED"}
      />
      <AnswerBox
        answer={questionData.answer || ""}
        answerDescription={questionData.answerDescription || ""}
        votes={questionData.votes || []}
      />
    </VStack>
  );
};

// Main render
return (
  <Box width={width} bg={colorMode === "light" ? "brand.background.light" : "brand.background.dark"}>
    <SearchBar
      onSearch={onSearch}
      onShuffle={onShuffle}
      onReset={onReset}
      onSubmit={onSubmit}
      currentQuestion={`Q${displayedQuestionInfo.current} of ${displayedQuestionInfo.total}`}
      currentTopic={currentTopic}
      totalQuestions={displayedQuestionInfo.total}
      onQuestionSelect={handleQuestionSelect}
    />
    <TabList
      tabs={tabs}
      onTabChange={handleTabChange}
      currentQuestionIndex={displayedQuestionInfo.current - 1}
      totalQuestions={displayedQuestionInfo.total}
      onNavigateLeft={() => handleNavigate(-1)}
      onNavigateRight={() => handleNavigate(1)}
      isNavigationDisabled={isNavigationDisabled || navigationLock}
      currentTab={currentTab}
    />
    {renderQuestions()}
  </Box>
);
};

export default QuestionPanel;
----
ResultsModal.js
import React from 'react';
import {
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  Button,
  Text,
  VStack,
  HStack,
  Progress,
  Box,
  Flex,
  useColorMode,
} from '@chakra-ui/react';
import { FaTimes } from 'react-icons/fa';

const StatusBadge = ({ status }) => {
  const { colorMode } = useColorMode();
  let bgGradient;
  let textColor = colorMode === 'light' ? "brand.text.light" : "brand.text.dark";
  
  switch (status) {
    case "PASSED":
      bgGradient = colorMode === 'light'
        ? "linear(to-r, #4CAF50, #8BC34A)"  // Light mode: Bright green gradient
        : "linear(to-r, #2E673F, #4A6F2E)"; // Dark mode: Darker green gradient
      break;
    case "FAILED":
      bgGradient = colorMode === 'light'
        ? "linear(to-r, #FF5252, #FF8A80)"  // Light mode: Bright red gradient
        : "linear(to-r, #992F2F, #994D4D)"; // Dark mode: Darker red gradient
      break;
    default:
      bgGradient = colorMode === 'light'
        ? "linear(to-r, #FFD54F, #FFF176)"  // Light mode: Bright yellow gradient
        : "linear(to-r, #997F30, #998E47)"; // Dark mode: Darker yellow gradient
  }
  
  return (
    <Box
      paddingLeft={2}
      paddingRight={2}
      paddingTop={0}
      paddingBottom={0}
      borderRadius="full"
      display="inline-block"
      alignSelf="center"
      border="1px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      bgGradient={bgGradient}
    >
      <Text fontSize="14px" fontWeight="500" color={textColor}>
        {status}
      </Text>
    </Box>
  );
};

const CloseButton = ({ onClick, colorMode }) => {
  return (
    <Box
      as="button"
      onClick={onClick}
      display="inline-flex"
      alignItems="center"
      justifyContent="center"
      w="24px"
      h="24px"
      bg="transparent"
      _focus={{ boxShadow: "none" }}
      color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
      borderRadius="50%"
      _hover={{ bg: 'transparent' }} // Ensures no background change on hover
    >
      <FaTimes size="16px" />
    </Box>
  );
};

const CustomButton = ({ children, onClick }) => {
  const { colorMode } = useColorMode();
  
  return (
    <Button
      onClick={onClick}
      height="48px"
      fontSize="16px"
      px="24px"
      bg={colorMode === 'light' ? "brand.primary.light" : "brand.primary.dark"}
      color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
      borderRadius="full"
      border="1px solid"
      borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
      fontWeight={700}
      textTransform="uppercase"
      transition="0.3s"
      boxShadow={colorMode === 'light' 
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
      }
      _hover={{
        transform: 'translateY(2px)',
        boxShadow: colorMode === 'light'
          ? "0 2px 0 0 black"
          : "0 2px 0 0 rgba(255, 255, 255, 0.2)",
      }}
      _active={{
        transform: 'translateY(4px)',
        boxShadow: 'none',
      }}
    >
      {children}
    </Button>
  );
};

const formatIncorrectQuestions = (incorrectQuestions) => {
  if (incorrectQuestions.length === 0) return '';

  const sortedQuestions = incorrectQuestions.sort((a, b) => {
    const [aTopic, aQ] = a.split(' ');
    const [bTopic, bQ] = b.split(' ');
    return aTopic.localeCompare(bTopic) || parseInt(aQ.slice(1)) - parseInt(bQ.slice(1));
  });

  let result = [];
  let currentTopic = '';
  let currentRange = [];

  sortedQuestions.forEach((q, index) => {
    const [topic, questionNum] = q.split(' ');
    if (topic !== currentTopic) {
      if (currentRange.length > 0) {
        result.push(formatRange(currentTopic, currentRange));
      }
      currentTopic = topic;
      currentRange = [parseInt(questionNum.slice(1))];
    } else {
      const prevNum = currentRange[currentRange.length - 1];
      const currentNum = parseInt(questionNum.slice(1));
      if (currentNum !== prevNum + 1 && currentRange.length > 0) {
        result.push(formatRange(currentTopic, currentRange));
        currentRange = [currentNum];
      } else {
        currentRange.push(currentNum);
      }
    }

    if (index === sortedQuestions.length - 1) {
      result.push(formatRange(currentTopic, currentRange));
    }
  });

  return result.join(', ');
};

const formatRange = (topic, range) => {
  if (range.length === 1) {
    return `${topic} Q${range[0]}`;
  } else if (range.length === 2) {
    return `${topic} Q${range[0]}, ${topic} Q${range[1]}`;
  } else {
    return `${topic} Q${range[0]}-${topic} Q${range[range.length - 1]}`;
  }
};

const ResultsModal = ({ isOpen, onClose, results }) => {
  const { colorMode } = useColorMode();

  return (
    <Modal isOpen={isOpen} onClose={onClose} size="lg">
      <ModalOverlay />
      <ModalContent
        borderRadius="20px"
        border="1px solid"
        borderColor={colorMode === 'light' ? "brand.border.light" : "brand.border.dark"}
        boxShadow={colorMode === 'light'
          ? "0 8px 0 0 black"
          : "0 8px 0 0 rgba(255, 255, 255, 0.2)"
        }
        bg={colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"}
        p={6}
      >
        <Flex justifyContent="flex-end">
          <CloseButton onClick={onClose} />
        </Flex>
        <ModalHeader
          fontFamily="heading"
          fontWeight="bold"
          fontSize="24px"
          pb={4}
          color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}
        >
          Exam Results
        </ModalHeader>
        <ModalBody>
          {results ? (
            <VStack spacing={4} align="stretch">
              <HStack justifyContent="space-between">
                <Text fontWeight="bold" color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}>
                  Score:
                </Text>
                <Text color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}>
                  {results.score}%
                </Text>
              </HStack>
              <Progress 
                value={results.score} 
                colorScheme={results.passed ? "green" : "red"}
                bg={colorMode === 'light' ? "brand.surface.light" : "brand.background.dark"}
              />
              <HStack justifyContent="space-between">
                <Text fontWeight="bold" color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}>
                  Result:
                </Text>
                <StatusBadge status={results.passed ? "PASSED" : "FAILED"} />
              </HStack>
              <HStack justifyContent="space-between">
                <Text fontWeight="bold" color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}>
                  Correct Answers:
                </Text>
                <Text color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}>
                  {results.correct_answers} / {results.total_questions}
                </Text>
              </HStack>
              {results.incorrect_questions.length > 0 && (
                <VStack align="stretch">
                  <Text fontWeight="bold" color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}>
                    Incorrect Questions:
                  </Text>
                  <Text color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}>
                    {formatIncorrectQuestions(results.incorrect_questions)}
                  </Text>
                </VStack>
              )}
            </VStack>
          ) : (
            <VStack spacing={4} align="center">
              <Text color={colorMode === 'light' ? "brand.text.light" : "brand.text.dark"}>
                Loading results...
              </Text>
            </VStack>
          )}
        </ModalBody>
        <ModalFooter>
          <Flex justifyContent="flex-end" width="100%">
            <CustomButton onClick={onClose}>
              Close
            </CustomButton>
          </Flex>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
};

export default ResultsModal;
----
SearchBar.js
import React, { useState, useRef, useEffect } from 'react';
import { Box, Input, InputGroup, InputLeftElement, InputRightElement, Flex, useColorMode } from '@chakra-ui/react';
import { SearchIcon, CloseIcon } from '@chakra-ui/icons';
import { PiShuffle } from "react-icons/pi";
import { RxReset } from "react-icons/rx";
import { PiSealFill, PiSeal } from "react-icons/pi";
import { MdFormatListNumbered } from "react-icons/md";
import QuestionListDropdown from './QuestionListDropdown';
import SubmitButton from './SubmitButton';

const SealedButton = React.memo(({ icon: Icon, onClick }) => {
  const { colorMode } = useColorMode();
  const [isPressed, setIsPressed] = useState(false);
  const size = '48px';
  const iconScale = 0.4;
  const iconSize = `${parseInt(size) * iconScale}px`;
  const borderThickness = 3;

  return (
    <Box
      position="relative"
      width={size}
      height={size}
      onClick={onClick}
      onMouseDown={() => setIsPressed(true)}
      onMouseUp={() => setIsPressed(false)}
      onMouseLeave={() => setIsPressed(false)}
      cursor="pointer"
      transition="all 0.1s ease"
      transform={isPressed ? 'scale(0.95)' : 'scale(1)'}
      userSelect="none"
    >
      <Box 
        as={PiSealFill} 
        size={size} 
        color={colorMode === 'light' ? 'brand.secondary.light' : 'brand.secondary.dark'} 
      />
      <Box
        as={PiSeal}
        size={size}
        color={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
        position="absolute"
        top="0"
        left="0"
        style={{
          width: size,
          height: size,
        }}
        sx={{
          svg: {
            strokeWidth: borderThickness,
            stroke: colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark',
            fill: 'none',
          },
          path: {
            strokeWidth: borderThickness,
            stroke: colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark',
            fill: 'none',
          },
        }}
      />
      <Flex
        position="absolute"
        top="50%"
        left="50%"
        transform="translate(-50%, -50%)"
        alignItems="center"
        justifyContent="center"
      >
        <Icon 
          size={iconSize} 
          color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'} 
        />
      </Flex>
    </Box>
  );
});

const SearchBar = ({ 
  placeholder = "Search questions...", 
  onSearch, 
  onShuffle, 
  onReset, 
  currentQuestion,
  currentTopic,
  totalQuestions,
  onQuestionSelect,
  onSubmit
}) => {
  const { colorMode } = useColorMode();
  const [searchTerm, setSearchTerm] = useState('');
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const dropdownRef = useRef(null);

  const handleSearch = (event) => {
    const value = event.target.value;
    setSearchTerm(value);
    if (onSearch) {
      onSearch(value);
    }
  };

  const clearSearch = () => {
    setSearchTerm('');
    if (onSearch) {
      onSearch('');
    }
  };

  const toggleDropdown = () => {
    setIsDropdownOpen((prevState) => !prevState);
  };

  const handleQuestionSelect = (question) => {
    if (onQuestionSelect) {
      onQuestionSelect(question);
    }
    setIsDropdownOpen(false);
  };

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsDropdownOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  const questions = Array.from({ length: totalQuestions }, (_, index) => `T${currentTopic} Q${index + 1}`);

  return (
    <Flex width="100%" marginBottom={4} alignItems="center" justifyContent="space-between">
      <InputGroup size="lg" flex={1} marginRight={4}>
        <InputLeftElement pointerEvents="none">
          <SearchIcon color={colorMode === 'light' ? 'gray.300' : 'gray.500'} />
        </InputLeftElement>
        <Input
          value={searchTerm}
          onChange={handleSearch}
          placeholder={placeholder}
          bg={colorMode === 'light' ? "brand.background.light" : "brand.surface.dark"}
          border="1px solid"
          borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
          borderRadius="12px"
          color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
          _focus={{
            boxShadow: `0 0 0 1px ${colorMode === 'light' ? 'black' : 'white'}`,
            borderColor: colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark',
          }}
          _hover={{
            borderColor: colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark',
          }}
          fontFamily='"Karla Variable", sans-serif'
          fontWeight={500}
          fontSize="16px"
        />
        {searchTerm && (
          <InputRightElement>
            <CloseIcon 
              color={colorMode === 'light' ? 'gray.500' : 'gray.400'} 
              cursor="pointer" 
              onClick={clearSearch} 
            />
          </InputRightElement>
        )}
      </InputGroup>
      <Flex ref={dropdownRef}>
        <Box position="relative">
          <SealedButton icon={MdFormatListNumbered} onClick={toggleDropdown} />
          {isDropdownOpen && (
            <QuestionListDropdown
              questions={questions}
              currentQuestion={currentQuestion}
              onSelect={handleQuestionSelect}
            />
          )}
        </Box>
        <Box width="8px" />
        <SealedButton icon={PiShuffle} onClick={onShuffle} />
        <Box width="8px" />
        <SealedButton icon={RxReset} onClick={onReset} />
        <Box width="8px" />
        <SubmitButton onClick={onSubmit} />
      </Flex>
    </Flex>
  );
};

export default SearchBar;
----
SelectExamBox.js
import React from 'react';
import { Box, Text, VStack, Button, Flex, useColorMode } from '@chakra-ui/react';
import { useNavigate } from 'react-router-dom';
import { FaPaperPlane } from 'react-icons/fa';

const SelectExamBox = () => {
  const navigate = useNavigate();
  const { colorMode } = useColorMode();

  return (
    <Flex 
      width="100%" 
      height="100%" 
      alignItems="flex-start" 
      justifyContent="center" 
      paddingTop="50px"
    >
      <Box
        width="100%"
        maxWidth="800px"
        bgGradient={colorMode === 'light'
          ? "linear(to-br, #8E2DE2, #4A00E0)"
          : "linear(to-br, #6620A3, #3500A3)"  // Darker, more muted versions of the purple gradients
        }
        borderRadius="20px"
        border="1px solid"
        borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
        boxShadow={colorMode === 'light'
          ? "0 8px 0 0 black"
          : "0 8px 0 0 rgba(255, 255, 255, 0.2)"
        }
        position="relative"
        overflow="hidden"
        padding={8}
      >
        <VStack spacing={6} align="stretch">
          <Text
            fontSize="48px"
            fontWeight="800"
            color="white"
            textAlign="center"
            fontFamily="heading"
            textShadow={colorMode === 'light'
              ? "2px 2px 4px rgba(0,0,0,0.2)"
              : "2px 2px 4px rgba(0,0,0,0.5)"
            }
          >
            Select an Exam
          </Text>
          <Text 
            fontSize="20px" 
            color={colorMode === 'light' ? '#E0E0E0' : '#CCCCCC'}
            textAlign="center" 
            lineHeight="1.6"
          >
            Please select an exam to begin your practice session.
          </Text>
          <Flex justifyContent="center">
            <Button
              onClick={() => navigate("/exams")}
              height="48px"
              fontSize="16px"
              paddingLeft="24px"
              paddingRight="24px"
              backgroundColor={colorMode === 'light' ? '#4FD1C5' : '#2E7A73'}  // Darker teal for dark mode
              color={colorMode === 'light' ? 'black' : 'white'}
              borderRadius="full"
              border="1px solid"
              borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
              fontWeight={700}
              textTransform="uppercase"
              transition="0.3s"
              boxShadow={colorMode === 'light'
                ? "0 4px 0 0 black"
                : "0 4px 0 0 rgba(255, 255, 255, 0.2)"
              }
              _hover={{
                transform: 'translateY(2px)',
                boxShadow: colorMode === 'light'
                  ? '0 2px 0 0 black'
                  : '0 2px 0 0 rgba(255, 255, 255, 0.2)',
                backgroundColor: colorMode === 'light' ? "#45B7AB" : "#266159",  // Darker hover states
              }}
              _active={{
                transform: 'translateY(4px)',
                boxShadow: 'none',
              }}
              leftIcon={<FaPaperPlane />}
            >
              Go to Exams Page
            </Button>
          </Flex>
        </VStack>
        <Box
          position="absolute"
          bottom="-50px"
          right="-50px"
          width="200px"
          height="200px"
          borderRadius="full"
          backgroundColor={colorMode === 'light'
            ? "rgba(255, 255, 255, 0.1)"
            : "rgba(255, 255, 255, 0.05)"
          }
          zIndex={0}
        />
      </Box>
    </Flex>
  );
};

export default SelectExamBox;

----
Sidebar.js
import React from "react";
import {
  Box,
  VStack,
  Text,
  Flex,
  chakra,
  Button,
  Icon,
  useColorMode,
  useColorModeValue,
} from "@chakra-ui/react";
import { GiDreamCatcher, GiCubeforce, GiSpellBook } from "react-icons/gi";
import { RxDashboard } from "react-icons/rx";
import { RiStackLine } from "react-icons/ri";
import {
  LuRocket,
  LuLogOut,
  LuChevronLeft,
  LuChevronRight,
} from "react-icons/lu";
import "@fontsource-variable/karla/wght.css";
import "@fontsource/space-grotesk/700.css";
import { useNavigate } from "react-router-dom";

// Chakra components with theme-aware styling
const SidebarItem = chakra(Flex, {
  baseStyle: {
    alignItems: "center",
    height: "52px",
    cursor: "pointer",
    transition: "all 0.2s",
    borderRadius: "0 20px 20px 0",
    marginRight: "16px",
    position: "relative",
    marginTop: "3px",
    marginBottom: "3px",
  }
});

const SidebarIcon = chakra(Box, {
  baseStyle: {
    fontSize: "24px",
    color: "inherit",
    position: "absolute",
    left: "20px",
    transition: "all 0.3s ease",
  }
});

const SidebarText = chakra(Text, {
  baseStyle: {
    fontFamily: "body",
    fontWeight: 500,
    fontSize: "18px",
    lineHeight: "27px",
    color: "inherit",
    marginLeft: "60px",
    transition: "opacity 0.3s ease",
  }
});

const PremiumBox = React.memo(({ isCollapsed }) => {
  const borderColor = useColorModeValue("brand.border.light", "brand.border.dark");
  const boxShadow = useColorModeValue(
    "0 4px 0 0 black",
    "0 4px 0 0 rgba(255, 255, 255, 0.2)"
  );
  const textColor = useColorModeValue("brand.text.light", "brand.text.dark");
  const buttonBg = useColorModeValue("white", "brand.surface.dark");
  const premiumGradient = useColorModeValue(
    "linear(135deg, #FFD700, #FFA500)",
    "linear(135deg, #B38600, #804000)"
  );

  return (
    <Box
      bgGradient={premiumGradient}
      borderRadius="20px"
      border="1px solid"
      borderColor={borderColor}
      boxShadow={boxShadow}
      padding={4}
      margin={4}
      position="relative"
      overflow="hidden"
      opacity={isCollapsed ? 0 : 1}
      transition="all 0.3s ease"
      pointerEvents={isCollapsed ? "none" : "auto"}
    >
      <Box
        position="absolute"
        top="-10px"
        right="-10px"
        width="80px"
        height="80px"
        borderRadius="full"
        backgroundColor="rgba(255, 255, 255, 0.2)"
      />
      <Flex direction="column" alignItems="center" justifyContent="center">
        <Text
          fontWeight="bold"
          fontSize="18px"
          color={textColor}
          marginBottom={3}
        >
          Your access is limited
        </Text>
        <Button
          variant="solid"
          backgroundColor={buttonBg}
          color={textColor}
          borderRadius="full"
          fontWeight="bold"
          border="1px solid"
          borderColor={borderColor}
          boxShadow={boxShadow}
          _hover={{
            transform: "translateY(-2px)",
          }}
          _active={{
            transform: "translateY(0)",
          }}
        >
          Go Premium! 
        </Button>
      </Flex>
    </Box>
  );
});

const Sidebar = ({ isCollapsed, onToggleCollapse, activeItem, lastVisitedExam }) => {
  const navigate = useNavigate();
  const { colorMode } = useColorMode();

  // Theme-aware color values
  const bgColor = useColorModeValue("brand.surface.light", "brand.surface.dark");
  const textColor = useColorModeValue("brand.text.light", "brand.text.dark");
  const itemColor = useColorModeValue("brand.text.light", "brand.text.dark");
  const borderColor = useColorModeValue("brand.border.light", "brand.border.dark");
  const activeItemBg = useColorModeValue("brand.secondary.light", "brand.secondary.dark");
  const boxShadow = useColorModeValue(
    "0 4px 0 0 black",
    "0 4px 0 0 rgba(255, 255, 255, 0.2)"
  );
  const logoutColor = useColorModeValue("gray.500", "gray.400");
  const hoverBg = useColorModeValue("brand.hover.light", "brand.hover.dark");
  const activeBg = useColorModeValue("brand.primary.light", "brand.primary.dark");
  const iconColor = useColorModeValue("brand.text.light", "brand.text.dark");

  const menuItems = [
    { name: "Dashboard", icon: RxDashboard, path: "/" },
    { name: "Providers", icon: GiCubeforce, path: "/providers" },
    { name: "Exams", icon: RiStackLine, path: "/exams" },
    { name: "Custom Exam", icon: GiSpellBook, path: "/custom-exam" },
    { name: "Actual Exam", icon: LuRocket, path: "/actual-exam" },
  ];

  const handleItemClick = (path, name) => {
    if (name === "Actual Exam" && lastVisitedExam) {
      navigate(`/actual-exam/${lastVisitedExam}`);
    } else {
      navigate(path);
    }
  };

  return (
    <Box
      backgroundColor={bgColor}
      width={isCollapsed ? "80px" : "300px"}
      height="100vh"
      padding="20px 0"
      position="relative"
      transition="all 0.3s ease"
    >
      {/* Logo section */}
      <Flex
        alignItems="center"
        justifyContent="center"
        marginBottom="60px"
        opacity={isCollapsed ? 0 : 1}
        transition="opacity 0.3s ease"
        pointerEvents={isCollapsed ? "none" : "auto"}
      >
        <Box display="flex" alignItems="center">
          <GiDreamCatcher
            size={32}
            color={colorMode === "light" ? iconColor : iconColor}
          />
          <Text
            marginLeft="8px"
            fontFamily="heading"
            fontSize="32px"
            fontWeight="bold"
            color={textColor}
            position="relative"
            transition="color 0.2s"
          >
            hiraya
            <sup
              style={{
                fontSize: "8px",
                position: "absolute",
                top: "15px",
                right: "-12px",
                color: textColor,
              }}
            >
              TM
            </sup>
          </Text>
        </Box>
      </Flex>

      {/* Menu Items */}
      <VStack spacing={2} align="stretch">
        {menuItems.map((item) => (
          <SidebarItem
            key={item.name}
            onClick={() => handleItemClick(item.path, item.name)}
            position="relative"
            zIndex={1}
            color={itemColor}
            _hover={{
              backgroundColor: hoverBg,
            }}
          >
            <Box
              position="absolute"
              top="-3px"
              left={0}
              right={0}
              bottom="-3px"
              backgroundColor={activeItem === item.name ? activeItemBg : "transparent"}
              borderRadius="0 20px 20px 0"
              borderTop={activeItem === item.name ? `1px solid ${borderColor}` : "none"}
              borderRight={activeItem === item.name ? `1px solid ${borderColor}` : "none"}
              borderBottom={activeItem === item.name ? `1px solid ${borderColor}` : "none"}
              boxShadow={activeItem === item.name ? boxShadow : "none"}
              zIndex={-1}
              transition="all 0.2s"
            />
            <SidebarIcon as={item.icon} />
            <SidebarText
              fontWeight={activeItem === item.name ? 700 : 500}
              opacity={isCollapsed ? 0 : 1}
              pointerEvents={isCollapsed ? "none" : "auto"}
            >
              {item.name}
            </SidebarText>
          </SidebarItem>
        ))}
      </VStack>

      {/* Premium Box */}
      <Box position="absolute" bottom="80px" left="0" right="0">
        <PremiumBox isCollapsed={isCollapsed} />
      </Box>

      {/* Logout Button */}
      <SidebarItem
        position="absolute"
        bottom="20px"
        left="0"
        right="0"
        zIndex={1}
        color={logoutColor}
        _hover={{
          "& > *": {
            color: "red.500",
          },
          transform: "translateY(-2px)",
        }}
      >
        <SidebarIcon as={LuLogOut} />
        <SidebarText
          opacity={isCollapsed ? 0 : 1}
          pointerEvents={isCollapsed ? "none" : "auto"}
        >
          Logout
        </SidebarText>
      </SidebarItem>

      {/* Collapse Toggle Button */}
      <Button
        position="absolute"
        top="24px"
        right="-32px"
        size="sm"
        width="14px"
        height="32px"
        borderRadius="0 16px 16px 0"
        onClick={onToggleCollapse}
        zIndex={2}
        backgroundColor={bgColor}
        border="1px solid"
        borderColor={borderColor}
        borderLeft="none"
        color={textColor}
        _hover={{ backgroundColor: hoverBg }}
        _active={{ backgroundColor: activeBg }}
        transition="all 0.2s"
        padding={0}
      >
        <Icon
          as={isCollapsed ? LuChevronRight : LuChevronLeft}
          fontSize="12px"
        />
      </Button>
    </Box>
  );
};

export default Sidebar;
----
SubmitButton.js
import React from 'react';
import { Button } from '@chakra-ui/react';

const SubmitButton = (props) => {

  return (
    <Button
      height="48px"
      fontSize="16px"
      px="24px"
      variant="solid"
      fontWeight={700}
      textTransform="uppercase"
      {...props}
    >
      SUBMIT
    </Button>
  );
};

export default SubmitButton;
----
TabList.js
import React from 'react';
import { Box, Button, ButtonGroup, Flex, Text, useColorMode } from '@chakra-ui/react';
import { PiArrowLeftBold, PiArrowRightBold } from "react-icons/pi";

const TabButton = ({ children, isSelected, ...props }) => {
  const { colorMode } = useColorMode();
  
  return (
    <Button
      variant="referral"
      bg={isSelected 
        ? colorMode === 'light' ? 'brand.primary.light' : 'brand.primary.dark'
        : colorMode === 'light' ? 'brand.surface.light' : 'brand.surface.dark'
      }
      color={isSelected 
        ? colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'
        : colorMode === 'light' ? 'gray.600' : 'gray.400'
      }
      _hover={{
        bg: isSelected
          ? colorMode === 'light' ? 'brand.primary.dark' : 'brand.primary.light'
          : colorMode === 'light' ? 'brand.secondary.light' : 'brand.secondary.dark'
      }}
      border="1px solid"
      borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
      {...props}
    >
      {children}
    </Button>
  );
};

const NavIconBox = ({ icon: Icon, onClick, isDisabled }) => {
  const { colorMode } = useColorMode();
  const [isPressed, setIsPressed] = React.useState(false);
  const [isHovered, setIsHovered] = React.useState(false);
  const size = '40px';
  const iconScale = 0.5;
  const iconSize = `${parseInt(size) * iconScale}px`;
  const borderThickness = '0.5px';

  const handleMouseDown = () => {
    if (!isDisabled) {
      setIsPressed(true);
    }
  };

  const handleMouseUp = () => {
    if (!isDisabled) {
      setIsPressed(false);
    }
  };

  const handleMouseEnter = () => {
    if (!isDisabled) {
      setIsHovered(true);
    }
  };

  const handleMouseLeave = () => {
    setIsHovered(false);
    setIsPressed(false);
  };

  return (
    <Box
      position="relative"
      width={size}
      height={size}
      onClick={isDisabled ? undefined : onClick}
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      cursor={isDisabled ? "not-allowed" : "pointer"}
      transition="all 0.1s ease"
      transform={isPressed && !isDisabled ? 'scale(0.95)' : 'scale(1)'}
      userSelect="none"
      opacity={isDisabled ? 0.5 : 1}
    >
      <Box
        position="absolute"
        top="0"
        left="0"
        width="100%"
        height="100%"
        borderRadius="50%"
        border={borderThickness + " solid"}
        borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
        backgroundColor="transparent"
      />
      <Flex
        position="absolute"
        top="50%"
        left="50%"
        transform="translate(-50%, -50%)"
        alignItems="center"
        justifyContent="center"
        width="100%"
        height="100%"
      >
        <Icon 
          size={iconSize} 
          color={isHovered && !isDisabled 
            ? colorMode === 'light' ? 'brand.primary.light' : 'brand.primary.dark'
            : colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'
          } 
          transition="color 0.2s ease"
        />
      </Flex>
    </Box>
  );
};

const TabList = ({ 
  tabs, 
  onTabChange, 
  currentQuestionIndex, 
  totalQuestions, 
  onNavigateLeft, 
  onNavigateRight,
  isNavigationDisabled,
  currentTab 
}) => {
  const { colorMode } = useColorMode();

  const handleTabChange = (selectedTab) => {
    if (selectedTab !== currentTab) {
      onTabChange(selectedTab);
    }
  };

  const handleNavigateLeft = () => {
    const isFirstQuestion = currentQuestionIndex === 0;
    if (!isNavigationDisabled && !isFirstQuestion) {
      onNavigateLeft(currentTab);
    }
  };

  const handleNavigateRight = () => {
    const isLastQuestion = currentQuestionIndex === totalQuestions - 1;
    if (!isNavigationDisabled && !isLastQuestion) {
      onNavigateRight(currentTab);
    }
  };

  const shouldDisableLeftNavigation = () => {
    if (isNavigationDisabled) return true;
    return currentQuestionIndex === 0;
  };

  const shouldDisableRightNavigation = () => {
    if (isNavigationDisabled) return true;
    return currentQuestionIndex === totalQuestions - 1;
  };

  return (
    <Box 
      backgroundColor={colorMode === 'light' ? 'brand.background.light' : 'brand.background.dark'}
      display="flex" 
      flexDirection="column" 
      alignItems="center" 
      width="100%" 
      marginBottom={4}
    >
      <ButtonGroup 
        isAttached={true} 
        variant="referral" 
        width="100%" 
        marginBottom={4}
      >
        {tabs.map((tab) => (
          <TabButton
            key={tab}
            isSelected={currentTab === tab}
            onClick={() => handleTabChange(tab)}
            flex={1}
            data-testid={`tab-${tab}`}
          >
            {tab}
          </TabButton>
        ))}
      </ButtonGroup>

      <Flex 
        width="100%" 
        justifyContent="space-between" 
        alignItems="center" 
        paddingTop={4}
        paddingBottom={4}
      >
        <NavIconBox 
          icon={PiArrowLeftBold} 
          onClick={handleNavigateLeft}
          isDisabled={shouldDisableLeftNavigation()}
          data-testid="navigate-left"
        />
        <Text 
          fontSize="lg" 
          color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
          data-testid="question-counter"
        >
          Question {currentQuestionIndex + 1} of {totalQuestions}
        </Text>
        <NavIconBox 
          icon={PiArrowRightBold} 
          onClick={handleNavigateRight}
          isDisabled={shouldDisableRightNavigation()}
          data-testid="navigate-right"
        />
      </Flex>
    </Box>
  );
};

export default TabList;
----
TopicBox.js
import React from 'react';
import { Box, Text, VStack, Flex, useColorMode } from '@chakra-ui/react';

const TopicBox = ({ topicNumber, examCode, examTitle }) => {
  const { colorMode } = useColorMode();
  const capitalizedExamCode = examCode.toUpperCase();

  // Gradient colors adjusted for light/dark modes
  const gradientColors = {
    light: "linear(to top left, #F7941E, #72C6EF, #00A651)", // Original bright gradient
    dark: "linear(to top left, #B55F0C, #2F7A9E, #00733A)"   // Darker, more muted version
  };

  return (
    <Flex
      direction="column"
      width="100%"
      bgGradient={gradientColors[colorMode]}
      borderRadius="20px"
      border="1px solid"
      borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
      boxShadow={colorMode === 'light'
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"}
      position="relative"
      overflow="hidden"
      padding={6}
    >
      <VStack spacing={4} align="stretch">
        <Box
          paddingX={2}
          paddingY={0}
          borderRadius="full"
          display="inline-block"
          alignSelf="flex-start"
          border="1px solid"
          borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
          backgroundColor={colorMode === 'light' 
            ? 'rgba(255, 255, 255, 0.7)'
            : 'rgba(255, 255, 255, 0.15)'}
        >
          <Text 
            fontSize="14px" 
            fontWeight="500" 
            color={colorMode === 'light' ? 'black' : 'white'}
          >
            Topic {topicNumber}
          </Text>
        </Box>
        <Text 
          fontSize="24px" 
          fontWeight="700" 
          color={colorMode === 'light' ? 'black' : 'white'}
          lineHeight="1.2"
        >
          {capitalizedExamCode}
        </Text>
        <Text 
          fontSize="20px" 
          fontWeight="700" 
          color={colorMode === 'light' ? 'black' : 'white'}
          lineHeight="1.2"
        >
          {examTitle}
        </Text>
      </VStack>
    </Flex>
  );
};

export default TopicBox;
----
TopicSelector.js
import React, { useState, useRef, useEffect } from 'react';
import { Box, Text, Flex, Button, VStack, useColorMode } from '@chakra-ui/react';
import { ChevronLeftIcon, ChevronRightIcon } from '@chakra-ui/icons';

const CONTAINER_HEIGHT = "300px";
const TOPICS_PER_PAGE = 10;

const TopicButton = ({ topic, isSelected, onClick }) => {
  const { colorMode } = useColorMode();
  
  return (
    <Button
      onClick={() => onClick(topic)}
      width="100%"
      height="40px"
      bg={isSelected 
        ? colorMode === 'light' ? 'brand.primary.light' : 'brand.primary.dark'
        : colorMode === 'light' ? 'brand.background.light' : 'brand.surface.dark'
      }
      color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
      fontWeight={700}
      fontSize="14px"
      borderRadius="10px"
      border="1px solid"
      borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
      boxShadow={isSelected 
        ? "none" 
        : colorMode === 'light'
          ? "0 2px 0 0 black"
          : "0 2px 0 0 rgba(255, 255, 255, 0.2)"
      }
      _hover={{
        bg: isSelected
          ? colorMode === 'light' ? 'brand.primary.dark' : 'brand.primary.light'
          : colorMode === 'light' ? 'brand.secondary.light' : 'brand.secondary.dark',
        transform: "translateY(1px)",
        boxShadow: isSelected 
          ? "none" 
          : colorMode === 'light'
            ? "0 1px 0 0 black"
            : "0 1px 0 0 rgba(255, 255, 255, 0.2)",
      }}
      _active={{
        transform: "translateY(2px)",
        boxShadow: "none",
      }}
      transition="all 0.2s"
    >
      Topic {topic}
    </Button>
  );
};

const TopicSelector = ({ availableTopics, currentTopic, onTopicChange }) => {
  const { colorMode } = useColorMode();
  const [currentPage, setCurrentPage] = useState(0);
  const scrollContainerRef = useRef(null);
  const totalPages = Math.ceil(availableTopics.length / TOPICS_PER_PAGE);

  const handlePageChange = (direction) => {
    setCurrentPage(prevPage => {
      const newPage = direction === 'left'
        ? Math.max(0, prevPage - 1)
        : Math.min(totalPages - 1, prevPage + 1);
      return newPage;
    });
  };

  useEffect(() => {
    if (scrollContainerRef.current) {
      scrollContainerRef.current.scrollTop = 0;
    }
  }, [currentPage]);

  if (availableTopics.length === 1) {
    return null;
  }

  return (
    <Box
      width="100%"
      bg={colorMode === 'light' ? 'brand.surface.light' : 'brand.surface.dark'}
      borderRadius="20px"
      border="1px solid"
      borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
      boxShadow={colorMode === 'light'
        ? "0 4px 0 0 black"
        : "0 4px 0 0 rgba(255, 255, 255, 0.2)"}
      padding={4}
    >
      <Text 
        fontSize="24px" 
        fontWeight="700" 
        color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'} 
        marginBottom={4}
      >
        Topics
      </Text>
      {availableTopics.length > 0 ? (
        <>
          <Box
            ref={scrollContainerRef}
            overflowY="auto"
            height={CONTAINER_HEIGHT}
            marginBottom={4}
            css={{
              '&::-webkit-scrollbar': {
                width: '8px',
              },
              '&::-webkit-scrollbar-track': {
                background: colorMode === 'light' ? '#f1f1f1' : '#2d2d2d',
                borderRadius: '4px',
              },
              '&::-webkit-scrollbar-thumb': {
                background: colorMode === 'light' ? '#888' : '#666',
                borderRadius: '4px',
              },
              '&::-webkit-scrollbar-thumb:hover': {
                background: colorMode === 'light' ? '#555' : '#888',
              },
            }}
          >
            <VStack spacing={3} align="stretch" padding={2}>
              {availableTopics
                .slice(currentPage * TOPICS_PER_PAGE, (currentPage + 1) * TOPICS_PER_PAGE)
                .map((topic) => (
                  <TopicButton
                    key={topic}
                    topic={topic}
                    isSelected={currentTopic === topic}
                    onClick={onTopicChange}
                  />
                ))}
            </VStack>
          </Box>
          <Flex justifyContent="space-between" alignItems="center">
            <Button
              onClick={() => handlePageChange('left')}
              isDisabled={currentPage === 0}
              leftIcon={<ChevronLeftIcon />}
              size="sm"
              bg={colorMode === 'light' ? 'brand.background.light' : 'brand.surface.dark'}
              color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
              fontWeight={700}
              fontSize="14px"
              borderRadius="full"
              border="1px solid"
              borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
              boxShadow={colorMode === 'light'
                ? "0 2px 0 0 black"
                : "0 2px 0 0 rgba(255, 255, 255, 0.2)"}
              _hover={{
                bg: colorMode === 'light' ? 'brand.secondary.light' : 'brand.secondary.dark',
                transform: "translateY(1px)",
                boxShadow: colorMode === 'light'
                  ? "0 1px 0 0 black"
                  : "0 1px 0 0 rgba(255, 255, 255, 0.2)",
              }}
              _active={{
                transform: "translateY(2px)",
                boxShadow: "none",
              }}
              _disabled={{
                opacity: 0.5,
                cursor: "not-allowed",
                boxShadow: "none",
              }}
            >
              Previous
            </Button>
            <Button
              onClick={() => handlePageChange('right')}
              isDisabled={currentPage === totalPages - 1}
              rightIcon={<ChevronRightIcon />}
              size="sm"
              bg={colorMode === 'light' ? 'brand.background.light' : 'brand.surface.dark'}
              color={colorMode === 'light' ? 'brand.text.light' : 'brand.text.dark'}
              fontWeight={700}
              fontSize="14px"
              borderRadius="full"
              border="1px solid"
              borderColor={colorMode === 'light' ? 'brand.border.light' : 'brand.border.dark'}
              boxShadow={colorMode === 'light'
                ? "0 2px 0 0 black"
                : "0 2px 0 0 rgba(255, 255, 255, 0.2)"}
              _hover={{
                bg: colorMode === 'light' ? 'brand.secondary.light' : 'brand.secondary.dark',
                transform: "translateY(1px)",
                boxShadow: colorMode === 'light'
                  ? "0 1px 0 0 black"
                  : "0 1px 0 0 rgba(255, 255, 255, 0.2)",
              }}
              _active={{
                transform: "translateY(2px)",
                boxShadow: "none",
              }}
              _disabled={{
                opacity: 0.5,
                cursor: "not-allowed",
                boxShadow: "none",
              }}
            >
              Next
            </Button>
          </Flex>
        </>
      ) : (
        <Text 
          fontSize="16px" 
          color={colorMode === 'light' ? 'gray.600' : 'gray.400'}
        >
          No topics available for this exam.
        </Text>
      )}
    </Box>
  );
};

export default TopicSelector;
--END--