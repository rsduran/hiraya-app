from flask import Flask
from flask_cors import CORS
from flask_sqlalchemy import SQLAlchemy
from config import Config

app = Flask(__name__)
app.config.from_object(Config)
CORS(app)
db = SQLAlchemy(app)

from routes import *

import os

class Config:
    SQLALCHEMY_DATABASE_URI = 'postgresql://postgres:password@localhost/hiraya-db'
    SQLALCHEMY_TRACK_MODIFICATIONS = False

from app import app, db
from utils import load_data_into_db

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
        load_data_into_db()
    app.run(debug=True)

from app import db

class Provider(db.Model):
    __table_args__ = {'schema': 'public'}
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), unique=True, nullable=False)
    is_popular = db.Column(db.Boolean, default=False)
    exams = db.relationship('Exam', backref='provider', lazy=True)

class Exam(db.Model):
    __table_args__ = {'schema': 'public'}
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    progress = db.Column(db.Integer, default=0)
    total_questions = db.Column(db.Integer, default=0)
    provider_id = db.Column(db.Integer, db.ForeignKey('public.provider.id'), nullable=False)
    topics = db.relationship('Topic', backref='exam', lazy=True)

class Topic(db.Model):
    __table_args__ = {'schema': 'public'}
    id = db.Column(db.Integer, primary_key=True)
    number = db.Column(db.Integer, nullable=False)
    data = db.Column(db.JSON, nullable=False)
    exam_id = db.Column(db.Integer, db.ForeignKey('public.exam.id'), nullable=False)

from flask import jsonify, abort, request
from app import app, db
from models import Provider, Exam, Topic
from utils import get_exam_order

@app.route('/api/providers', methods=['GET'])
def get_providers():
    page = request.args.get('page', type=int)
    per_page = request.args.get('per_page', type=int)
    
    if page is None or per_page is None:
        providers = Provider.query.all()
        return jsonify({
            'providers': [
                {
                    'name': provider.name,
                    'exams': sorted([
                        {
                            'id': f"{provider.name}-{exam.title}",
                            'title': exam.title,
                            'progress': exam.progress,
                            'totalQuestions': exam.total_questions,
                            'order': get_exam_order(exam.title, provider.name)
                        } for exam in provider.exams
                    ], key=lambda x: (x['order'], x['title'])),
                    'isPopular': provider.is_popular
                } for provider in providers
            ],
            'total': len(providers),
            'pages': 1,
            'current_page': 1
        })
    else:
        providers = Provider.query.paginate(page=page, per_page=per_page, error_out=False)
        return jsonify({
            'providers': [
                {
                    'name': provider.name,
                    'exams': sorted([
                        {
                            'id': f"{provider.name}-{exam.title}",
                            'title': exam.title,
                            'progress': exam.progress,
                            'totalQuestions': exam.total_questions,
                            'order': get_exam_order(exam.title, provider.name)
                        } for exam in provider.exams
                    ], key=lambda x: (x['order'], x['title'])),
                    'isPopular': provider.is_popular
                } for provider in providers.items
            ],
            'total': providers.total,
            'pages': providers.pages,
            'current_page': page
        })

@app.route('/api/exams/<exam_id>', methods=['GET'])
def get_exam(exam_id):
    if exam_id == 'undefined' or '-' not in exam_id:
        abort(400, description="Invalid exam ID")
    
    provider_name, exam_title = exam_id.split('-', 1)
    provider = Provider.query.filter_by(name=provider_name).first()
    if not provider:
        abort(404, description="Provider not found")
    
    exam = Exam.query.filter_by(title=exam_title, provider_id=provider.id).first()
    if not exam:
        abort(404, description="Exam not found")
    
    exam_data = {
        'id': exam_id,
        'provider': provider.name,
        'examTitle': exam.title,
        'examCode': '',
        'topics': {topic.number: topic.data for topic in exam.topics}
    }
    
    exam_title_parts = exam.title.split('-code-')
    if len(exam_title_parts) == 2:
        exam_data['examTitle'], exam_data['examCode'] = exam_title_parts
    
    return jsonify(exam_data)

import os
import json
import re
from app import db
from models import Provider, Exam, Topic

def format_exam_title(exam_file):
    filename = exam_file.replace('.json', '')
    filename = re.sub(r'__topic-\d+', '', filename)
    parts = filename.split('_')
    if len(parts) > 1:
        filename = '_'.join(parts[1:])
    return filename

def load_data_into_db():
    root_dir = 'providers'
    for provider_name in os.listdir(root_dir):
        provider_path = os.path.join(root_dir, provider_name)
        if os.path.isdir(provider_path):
            provider = Provider.query.filter_by(name=provider_name).first()
            if not provider:
                provider = Provider(name=provider_name, is_popular=provider_name.lower() in ['amazon', 'microsoft', 'google'])
                db.session.add(provider)
                db.session.commit()

            exam_question_counts = {}

            for exam_file in os.listdir(provider_path):
                if exam_file.endswith('.json'):
                    file_path = os.path.join(provider_path, exam_file)
                    with open(file_path, 'r') as f:
                        exam_data = json.load(f)
                    
                    exam_title = format_exam_title(exam_file)
                    question_count = max(question['index'] for question in exam_data) if exam_data else 0
                    
                    exam_question_counts[exam_title] = exam_question_counts.get(exam_title, 0) + question_count
                    
                    exam = Exam.query.filter_by(title=exam_title, provider_id=provider.id).first()
                    if not exam:
                        exam = Exam(title=exam_title, total_questions=0, provider_id=provider.id)
                        db.session.add(exam)
                        db.session.commit()
                    
                    topic_number_match = re.search(r'__topic-(\d+)', exam_file)
                    topic_number = int(topic_number_match.group(1)) if topic_number_match else 1
                    
                    topic = Topic.query.filter_by(number=topic_number, exam_id=exam.id).first()
                    if not topic:
                        topic = Topic(number=topic_number, data=exam_data, exam_id=exam.id)
                        db.session.add(topic)
            
            for exam_title, total_questions in exam_question_counts.items():
                exam = Exam.query.filter_by(title=exam_title, provider_id=provider.id).first()
                if exam:
                    exam.total_questions = total_questions
            
            db.session.commit()

def get_exam_order(exam_title, provider_name):
    if provider_name.lower() == 'amazon':
        order_map = {
            'AWS Certified Cloud Practitioner': 1,
            'AWS Certified Solutions Architect Associate': 2,
            'AWS Certified Developer Associate': 3,
            'AWS Certified SysOps Administrator Associate': 4,
            'AWS Certified Solutions Architect Professional': 5,
            'AWS Certified DevOps Engineer Professional': 6,
            'AWS Certified Advanced Networking Specialty': 7,
            'AWS Certified Data Analytics Specialty': 8,
            'AWS Certified Database Specialty': 9,
            'AWS Certified Machine Learning Specialty': 10,
            'AWS Certified Security Specialty': 11,
            'AWS Certified SAP On AWS Specialty': 12,
            'AWS Certified Data Engineer Associate': 13,
            'AWS Certified Alexa Skill Builder Specialty': 14,
            'AWS Certified Big Data Specialty': 15,
        }
        
        version_priority = {
            'C03': 1,
            'C02': 2,
            'C01': 3,
            'C00': 4,
        }
        
        base_order = 100
        for key, value in order_map.items():
            if key.lower() in exam_title.lower():
                base_order = value
                break
        
        for version, priority in version_priority.items():
            if version in exam_title:
                return base_order * 10 + priority
        
        return base_order * 10

    elif provider_name.lower() == 'google':
        order_map = {
            'Google Cloud Digital Leader': 1,
            'Google Associate Cloud Engineer': 2,
            'Google Professional Cloud Architect': 3,
            'Google Professional Data Engineer': 4,
            'Google Professional Cloud Developer': 5,
            'Google Professional Cloud Network Engineer': 6,
            'Google Professional Cloud Security Engineer': 7,
            'Google Professional Cloud DevOps Engineer': 8,
            'Google Professional Machine Learning Engineer': 9,
            'Google Professional Cloud Database Engineer': 10,
            'Google Professional Google Workspace Administrator': 11,
            'Google Professional ChromeOS Administrator': 12,
            'Google G Suite Certification': 13,
            'Google Professional Collaboration Engineer': 14,
            'Google Search Advertising': 15,
            'Google Video Advertising': 16,
            'Google Ads Individual Qualification': 17,
            'Google Analytics Individual Qualification': 18,
            'Google AdWords Fundamentals': 19,
        }
        
        # Special handling for specific exams
        if 'Google Professional ChromeOS Administrator' in exam_title:
            return 12
        elif 'Google G Suite Certification' in exam_title:
            return 13
        elif 'Google Professional Collaboration Engineer' in exam_title:
            return 14
        elif 'Google Analytics Individual Qualification' in exam_title:
            return 18
        elif 'Google AdWords Fundamentals' in exam_title:
            return 19
        
        for key, value in order_map.items():
            if key.lower() in exam_title.lower():
                return value
        return 100

    return 0